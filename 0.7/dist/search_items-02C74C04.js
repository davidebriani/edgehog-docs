searchNodes=[{"type":"extras","title":"Introduction","doc":"Edgehog is an Open Source IoT platform focused on device fleet management. It conveniently handles fundamental operations such as performing update campaigns, getting device status information, geolocation and much more. It is based on Astarte . This documentation provides information on daily operations for Edgehog users and integrators. It goes through fundamental operations such as performing updates, querying APIs , integrating 3rd party applications, etc.","ref":"intro_user.html"},{"type":"extras","title":"Core concepts","doc":"This page will illustrate some of the core concepts used in Edgehog.","ref":"core_concepts.html"},{"type":"extras","title":"Core concepts - Hardware types, Devices and System Models","doc":"This section will deal with the difference between three main concepts used throughout Edgehog: Hardware Types, Devices and System Models. To better illustrate this, we will use as example the ACME Inc company, which manages a fleet of e-bikes and electric scooters. We will illustrate the hierarchy going from the bottom up, showing how each concept relates to the other ones. Hardware Type An Hardware Type represents the electronic hardware components embedded in an device. As an example, a possible Hardware Type description could be &quot;ESP32 with a GSM module&quot; or &quot;RaspberryPi 0 with an LTE modem&quot;. Each Hardware Type can have one or more Hardware Type Part Numbers associated with it. This makes sure that the user is able to map, e.g., a new revision of the PCB to the same Hardware Type, since different hardware with the same Hardware Type is assumed to be compatible. Usually (but not necessarily) the Hardware Type Part Number is a code that is written on the PCB. Device A device is an entity connected to Astarte. A Device has a uniquely identified by its Device ID, and it usually lives inside a product such as an e-bike (if it is not on a shelf or in a repair shop). System Model A System Model constitutes a group of devices implementing the same functionality for some users. For example, two e-bikes can be physically identical and still belong to different System Models, since they can have different software running on them. A System Model is associated with a specific Hardware Type, so two devices implementing the same functionality but using different Hardware Types will belong to two different System Models. This makes it so that the System Model is the fundamental identifier when it comes to software updates. A System Model has one or more System Model Part Numbers asociated with it, allowing to track newer versions of a product which do not change its main functionality. Usually (but not necessarily) the System Model's Part Number is delivered along with the device, or on the box containing it. Drawing again from our bike sharing example, e-bikes and electric scooters would have two different System Models, even if they use the same Hardware Type (e.g. an ESP32 with a GSM module). It is also possible that the e-bikes are further split into different System Models depending on the country they are deployed in if, for example, the software has to conform to speed limitations which are specific for each country.","ref":"core_concepts.html#hardware-types-devices-and-system-models"},{"type":"extras","title":"Core concepts - Tags, attributes and groups","doc":"This section will deal with various types of properties that can be added to devices to identify and group them. Tags Tags are string values that can be freely attached to Devices. There is no predefined semantics so users are free to use them as they see fit. Some examples of tags that can be assigned to the e-bikes or electric scooters in our examples could be out-of-order , test_machine or Upgraded Brakes . Attributes* * This feature is planned for a future release Attributes are namespaced key-value pairs that can be attached to Devices. The namespacing happens by prepending the namespace to the key using a colon as separator (i.e. namespace:key ). This ensures that the same key in different namespaces can be addressed unambiguously. The attribute keys are always strings, while values support all the types supported by Astarte Interfaces . The majority of attributes are automatically populated using different mechanisms depending on the namespaces, but there's also the possibility of manually defining custom attributes for a specific device. The supported namespaces are: edgehog-synthetic : automatically populated with values coming from Device data that is derived from Edgehog (e.g. Geolocation, System Model, Hardware Type, etc...) edgehog-policy : automatically populated with Edgehog values which are imposed on the cloud side (e.g. Geolocation disabled due to GDPR restrictions). astarte-values : automatically populated with values coming from device-owned Astarte interfaces using an Attribute Value Source with type astarte-value . astarte-attributes : automatically populated using the attributes map in the Device status returned from Astarte AppEngine API. Since Astarte attributes don't provide a trigger mechanism, these attributes are lazily populated and should be considered eventually consistent. custom : user-defined key-value pairs which are manually assigned to a Device. Note that all values will be converted to a string when using them as attribute values Attribute Value Source* * This feature is planned for a future release An Attribute Value Source populates the attributes of a Device according to some rule. Currently, the only supported type of Attribute Value Source is astarte-value , which updates Device attributes using a value from an Astarte interface. Selector A Selector allows selecting a subset of Devices based on their tags and attributes. The Selector can be evaluated for a Device and return true if the Device matches the Selector and false otherwise. Each Selector can be made of one or more filters, combined using and and or and (possibly) parenthesized. When no parenthesis are present, and has a higher priority than or in expressions. Supported filters Tag filter Created with the syntax &quot;&lt;value&gt;&quot; in tags , it returns true if value is included in the Device tags. It's also possible to use a negative filter with &quot;value&quot; not in tags , in this case the filter will match all Devices which don't have the tag. Attribute filter* * Note that while Attribute filters are already supported, Attributes are going to be available in a future release Created with the syntax attributes[&quot;&lt;namespace&gt;:&lt;key&gt;&quot;] &lt;operator&gt; &lt;value&gt; , it returns true if the value of the chosen attribute satisfies the expression. The supported operators are: == and != for all value types &gt; , &gt;= , &lt; , &lt;= for numeric or datetime values &lt;value&gt; can be a boolean ( true or false ), a string, a number (either integer or float), or one of the values supported using special syntax: now() indicates the current datetime at the time the Selector is evaluated. This can be used to do comparisons with other datetime attributes. datetime(&quot;&lt;ISO8601 string&gt;&quot;) is used to pass datetime values in expressions. The string contained in double quotes must be a valid UTC ISO8601 timestamp. Example: datetime(&quot;2022-06-27T16:27:40.254795Z&quot;) . binaryblob(&quot;&lt;base64 encoded value&gt;&quot;) is used to pass binaryblob values in expressions. The string contained in double quotes must be a valid Base64 encoding of the binary value. Example: binaryblob(&quot;Zm9vYmFy&quot;) to encode the string &quot;foobar&quot; . Attribute inclusion filter* * This feature is planned for a future release &quot;&lt;value&gt;&quot; in attributes[&quot;&lt;namespace&gt;:&lt;key&gt;&quot;] : returns true if value is included in the chosen attribute. Note that the attribute must be an array for the expression to be valid. Examples To provide some examples, here is a Selector to target all out of order Devices in Milan: &quot;out-of-order&quot; in tags and attributes [ &quot;edgehog-synthetic:city&quot; ] == &quot;Milan&quot; Here is a selector to target all Devices that have their service timestamp in the past so they have to be serviced, imagining this information is contained in the com.foo.ServiceInfo Astarte interface in the /serviceTimestamp : attributes [ &quot;astarte-values:com.foo.ServiceInfo/serviceTimestamp&quot; ] &lt;= now ( ) Caveats Note that numeric values are conflated in a single numeric type, i.e. a selector with attributes[&quot;custom:foo&quot;] == 42 will match either if foo is integer , longinteger or double (e.g it will also match 42.0 ). Another important thing to notice is that using an Attribute Filter will implicitly match only Devices that have that attribute. As an example, if there are 3 devices, one with attribute foo:bar == 42 , the other with attribute foo:bar == 3 and the third one with no foo:bar attribute, the Attribute Filter attributes[&quot;foo:bar&quot;] != 42 will match the second Device but not the third one, since it doesn't have the target attribute. In the future, additional syntax could be added to Selectors to allow filtering based just on the presence or absence of an attribute. Group A Group represents a subset of devices filtered by a Selector. The Group can be used to perform operations on Devices contained in it. Since Tags and Attributes of a Device can change, Groups do not statically define the set of Devices they contain but they change dynamically following Device changes. Note that a Device can't be manually assigned to a Group, its tags and attributes must be used to make it satisfy the group Selector.","ref":"core_concepts.html#tags-attributes-and-groups"},{"type":"extras","title":"Hardware Types","doc":"For each hardware type the following information can be displayed and edited. Name: a user friendly name, such as &quot;Strawberry Pi 5&quot; Handle: a machine friendly identifier, such as &quot;strawberry-pi-5&quot; (it must be a lower case, alpha numeric string, with no spaces and dashes allowed in the middle) Part Numbers: a list of part numbers, such as &quot;STBEPI-5-MA-2GB-REV1&quot;,&quot;STBEPI-5-MB-8GB-REV1&quot;, &quot;STBEPI-5-MB-8GB-REV2&quot;, etc... Multiple part numbers can be entered using the &quot;Add Part Number&quot; button.","ref":"hardware_types.html"},{"type":"extras","title":"Hardware Types - Create Hardware Type","doc":"This page allows creating a new hardware type, once created it can be edited at a later time.","ref":"hardware_types.html#create-hardware-type"},{"type":"extras","title":"Hardware Types - Update Hardware Type","doc":"By clicking the link on the hardware type list it is possible to open the detailed Hardware Type page. It is possible to edit the existing hardware type and to update it clicking the &quot;Update&quot; button.","ref":"hardware_types.html#update-hardware-type"},{"type":"extras","title":"System Models","doc":"As already mentioned in the Core concepts , System Model represent a group of devices providing the same functionalities to users. In Edgehog a System Model has this information associated with it: Name: a user friendly name used to identify the System Model (e.g. &quot;E-Bike v2&quot;) Handle: a machine friendly identifier for the System Model (e.g. &quot;e-bike-v2&quot;). A valid handle must begin with a lowercase letter followed by any number of lower case letters, numbers or dashes ( - ). Hardware type: the Hardware Type that is used for this system model. Each System Model is associated with exactly one Hardware Type. Part numbers: the Part Numbers for this System Model. Each System Model can have one or more Part Numbers associated with it, and Devices will be associated with a System Model based on the Part Number they declare to implement. Picture: each System Model can have a picture associated with it, so that Devices using that System Model can be identified at a glance. The following sections will illustrate all the pages that can be used to list, create and edit System Models.","ref":"system_models.html"},{"type":"extras","title":"System Models - System Model List","doc":"In the system model list you can see all the System Models that are available. All information relative to each System Model (minus the picture) is present in the table, and clicking on the name brings to the System Model page. Clicking on the &quot;Create System Model&quot; button in the top right brings to Create System Model page.","ref":"system_models.html#system-model-list"},{"type":"extras","title":"System Models - System Model","doc":"The System Model page shows the information about a specific System Model and allows updating all of them except the Hardware Type. Editing any field and then pressing the &quot;Update&quot; button saves the new values for the System Model. The &quot;Add Part Number&quot; button allows adding additional Part Numbers to a System Model, and the thrash icon on the right of each of them allows deleting them.","ref":"system_models.html#system-model"},{"type":"extras","title":"System Models - Create System Model","doc":"The Create System Model page allows creating a new System Model. The System Model information can be provided using the form, and pressing the &quot;Update&quot; button saves the System Model. The Hardware Type must be chosen from a list of available Hardware Types using the dropdown menu. The &quot;Add Part Number&quot; button allows adding additional Part Numbers for the System Model.","ref":"system_models.html#create-system-model"},{"type":"extras","title":"Devices","doc":"As mentioned in the core concepts , a Device is an entity connected to Astarte. In the device list you can see all the Devices that are available. For each Device the following information can be displayed: Name: a user friendly name Device ID: the ID that uniquely identifies the device connecting to Astarte System Model: the System Model associated to the Device Hardware Type: the Hardware Type associated to the Device's System Model Status: Reports the connection status, indicating whether the Device is connected to Astarte Last Seen: Reports the time of the last connection activity of the Device Clicking on a Device's name brings to a page dedicated to that Device to display additional info.","ref":"devices.html"},{"type":"extras","title":"Devices - Adding a Device","doc":"Each Device will become visible in Edgehog automatically the first time it connects to Astarte. Indeed, Astarte informs Edgehog about the Device's presence and activity via Astarte Triggers, which should be configured to relay the appropriate events.","ref":"devices.html#adding-a-device"},{"type":"extras","title":"Devices - Associating a Device to a System Model","doc":"Each Device is associated to a specific System Model. The System Model is the fundamental identifier when it comes to software updates, since it dictates which software is supported and what functionalities should be configured. However, during its lifetime, a Device can be tied to different System Models. Say, for example, that two different models of e-bikes are sent to maintenance; if they share the same hardware, the working PCB board of one model could be fitted into the other one. For this reason, each time a Device connects to Astarte, it can notify Astarte about the System Model it refers to, exposing its Part Number. Astarte then informs Edgehog via Astarte Triggers, so that Edgehog can associate the Device to the correct System Model by matching the Device's Part Number with the ones of the System Model.","ref":"devices.html#associating-a-device-to-a-system-model"},{"type":"extras","title":"Devices - Tags and Attributes","doc":"A Device can have some Tags and Attributes associated with it. Tags are purely user-defined and can be added and removed from the Device page. Attributes are mostly automatically populated but the custom namespace attributes can be assigned freely from the Device page. Tags and attributes can be used to determine the membership of a Device to a specific group , which in turn can be used to assign a Device to a specific Update Channel when receiving OTA Updates .","ref":"devices.html#tags-and-attributes"},{"type":"extras","title":"Devices - Device info","doc":"On the page of each Device different sets of data are shown. On top of the basic info already visible in the device list, additional sections can be displayed here to report operational data exposed by the device. The details about how devices publish such data are explained in Interacting with Edgehog . Hardware info This section reports an overview on the general hardware capabilities of the Device. Operating System This section reports an overview of the operating system of the Device. Runtime This section reports an overview about the Edgehog runtime running on the Device. Base Image This section reports an overview of the Base Image of the Device. System status This section reports an overview on the current system status of the Device. Storage Status This section reports an overview on the capacity and usage of the storage units of the Device. Battery status This section reports an overview on the current status of the battery slots of the Device. Cellular Connection This section reports an overview of the cellular connection of the Device. Network Interfaces This section reports the list of network interfaces of the Device. Nearby WiFi APs This section reports the list of nearby Access Points that the Device found while scanning for WiFi signals. Geolocation This section reports the approximate location of the Device, using Edgehog's geolocation modules to estimate a set of GPS coordinates. Depending on the data exposed by the Device, the coordinates can be estimated from: the GPS position published via the Astarte interface io.edgehog.devicemanager.Geolocation . nearby WiFi APs that the Device detected recently, published via the Astarte interface io.edgehog.devicemanager.WiFiScanResults the IP address used by the Device to connect to Astarte Based on the available data, Edgehog's geolocation modules try to find to best estimate by relying on the most up-to-date info and using the ones that provide the most accuracy.","ref":"devices.html#device-info"},{"type":"extras","title":"SDKs & Runtime","doc":"","ref":"device_sdks_runtime.html"},{"type":"extras","title":"SDKs & Runtime - Edgehog Device ESP32 SDK","doc":"Edgehog Device ESP32 is an ESP-IDF component written in C, that enables remote device management using Edgehog. edgehog-esp32-device documentation","ref":"device_sdks_runtime.html#edgehog-device-esp32-sdk"},{"type":"extras","title":"SDKs & Runtime - Edgehog Device Runtime","doc":"Edgehog Device Runtime is a portable middleware written in Rust, that enables remote device management using Edgehog. edgehog-device-runtime","ref":"device_sdks_runtime.html#edgehog-device-runtime"},{"type":"extras","title":"Attribute Value Sources","doc":"Device attributes can be populated using external sources using Attribute Value Sources. These provide mechanisms to automatically update some device attributes according to some rules. All the concepts used below are detailed in the Core Concepts page, this guide is oriented towards operational details to use Attribute Value Sources.","ref":"attribute_value_sources.html"},{"type":"extras","title":"Attribute Value Sources - Populating attributes using Astarte values","doc":"To populate an attribute using a value coming from an Astarte interface, an Attribute Value Source of type astarte-value must be added. This will populate an attribute whose value will be eventually consistent with the value of the target Astarte interface and path. When creating an astarte-value Attribute Value Source, the following information must be provided: Interface: the target interface to be used Major version: the target major version of the interface Path: the target path containing the value that will be used as attribute value After its creation, the Attribute Value Source will install an Astarte trigger, so when the target interface value changes, the change will be (eventually) reflected in the Attribute value. The Attribute key will be astarte-value:&lt;interface-name&gt;&lt;path&gt; . The value will also be initialized asynchronously for all devices by querying AppEngine API in a background task.","ref":"attribute_value_sources.html#populating-attributes-using-astarte-values"},{"type":"extras","title":"Groups","doc":"Edgehog allows creating groups of Devices based on tags and attributes. This makes it easy to target them with fleet operations. All the concepts used below are detailed in the Core Concepts page, this guide is oriented towards operational details to create a group.","ref":"groups.html"},{"type":"extras","title":"Groups - Creating a group","doc":"A new group can be created from the Groups section of Edgehog. When creating a group, the following information must be provided: Name: the display name of the group Handle: an handle matching the ^[a-z][a-z\\d\\-]*$ regular expression. Selector: a Selector that will determine which Devices belong to this group (i.e. all Devices that match the Selector)","ref":"groups.html#creating-a-group"},{"type":"extras","title":"Groups - Deleting a group","doc":"To delete a group, just press the Delete icon next to it in the group list. Note that deleting a group means that all automatic operations based on that group (e.g. Update Channel auto-assignment) will cease to work.","ref":"groups.html#deleting-a-group"},{"type":"extras","title":"Batch Operations*","doc":"* This feature is planned for a future release Edgehog provides facilities to perform batch operations on groups of devices. These are used to avoid having to perform repetitive tasks on many devices. This guide presents the batch operations which can be performed using Edgehog.","ref":"batch_operations.html"},{"type":"extras","title":"Batch Operations* - Maintenance Window Setting","doc":"Using the Edgehog API or its frontend, it is possible to set the same Maintenance Window to all devices belonging to a Group. When performing the operation, the following information must be provided Maintenance Window Start: the UTC timestamp that marks the beginning of the Maintenance Window Maintenance Window End: the UTC timestamp that marks the end of the Maintenance Window Group: the name of the target group All devices belonging to the Group when the operation is started will be assigned the new Maintenance Window. Note that the Maintenance Window remains a property of the single device and the assignment is performed one-shot when the operation is performed (i.e. Devices that become member of the group later are not affected by it).","ref":"batch_operations.html#maintenance-window-setting"},{"type":"extras","title":"OTA Update concepts","doc":"This page will illustrate some of the OTA Update concepts used in Edgehog.","ref":"ota_update_concepts.html"},{"type":"extras","title":"OTA Update concepts - Base Image","doc":"A Base Image is an image created to be run on a Device. The exact content of the Base Image can vary depending on the use case, but it usually contains the operating system image or the device firmware. Each Base Image belongs to a Base Image Collection . Base Images follow semantic versioning, so that the user is able to know when a specific update can contain breaking changes. Each Base Image must have a unique version number.","ref":"ota_update_concepts.html#base-image"},{"type":"extras","title":"OTA Update concepts - Base Image Collection","doc":"A Base Image Collection is a set of Base Images associated with a specific System Model and, implicitly via the System Model, with a specific Hardware Type . The mapping relation between Base Image Collection and System Models is 1:1, so a Base Image Collection is associated with a single System Model and viceversa. A Base Image Collection contains all the Base Images that ran, are running or could be run on a System Model. Drawing from the bike sharing example, there would be a different Base Image Collection for, e.g., e-bikes from each specific country to handle the different speed limitations. The primary purpose of a Base Image Collection is to limit what can be installed to a System Model, preventing unintended installations, such as electric scooter firmware on an e-bike.","ref":"ota_update_concepts.html#base-image-collection"},{"type":"extras","title":"OTA Update concepts - Version Requirement","doc":"A Version Requirement specifies compatibility between versions. It is expressed as a string containing various criteria and adheres to syntax detailed in Elixir's Version.Requirement . For example, when the Version Requirement &gt;= 2.0.0 and &lt; 3.0.0 is used to define the Supported starting versions of Base Image foo , it identifies a subset of Base Images within the same Base Image Collection that can be updated to the Base Image foo .","ref":"ota_update_concepts.html#version-requirement"},{"type":"extras","title":"OTA Update concepts - Update Channel","doc":"An Update Channel represents the subscription of a Device to a specific set of Base Images. To assign a Device to a specific Update Channel (other than the default one) the device must belong to a Group and that Group has to be assigned to the Target Groups of the Update Channel. The same Base Image can be associated with multiple Update Channels. This guarantees that once testers in the beta Update Channel validate the Base Image, the exact same Base Image will be used to update devices in the default Update Channel.","ref":"ota_update_concepts.html#update-channel"},{"type":"extras","title":"OTA Update concepts - Update Campaign","doc":"An Update Campaign is the operation that tracks the distribution of a specific Base Image to all devices belonging to an Update Channel. An Update Campaign can define additional constraints about which devices can be updated (e.g. minimum current version, force downgrade, etc).","ref":"ota_update_concepts.html#update-campaign"},{"type":"extras","title":"OTA Update concepts - Rollout Mechanism","doc":"The Rollout Mechanism determines the details of how an Update Campaign is carried out. It is responsible of deciding if the update is pushed towards the devices or pulled by users interacting with them. It also defines other details like how many devices are updated at a time, how many errors should be supported before aborting the campaign etc. There are currently two main Mechanisms available: Push and Optional*. The Push mechanism pushes the update towards the device unconditionally, while the Optional mechanism waits for a confirmation on the Device side (usually given by a user) before starting to download the update. * The Optional rollout mechanism is planned for a future release","ref":"ota_update_concepts.html#rollout-mechanism"},{"type":"extras","title":"OTA Update concepts - OTA Operation","doc":"An OTA Operation tracks the progress of an update to a specific Device. It is started when Edgehog starts pushing the update to the Device and ends either with a success or with an error (possibly due to a timeout).","ref":"ota_update_concepts.html#ota-operation"},{"type":"extras","title":"OTA Update concepts - Update Target","doc":"An Update Target is the target of an Update Campaign, which is composed by the targeted device, the status of the target in the linked Update Campaign, OTA Operation and additional metadata.","ref":"ota_update_concepts.html#update-target"},{"type":"extras","title":"OTA Update concepts - Maintenance Window*","doc":"* This feature is planned for a future release Each Device can have an optional Maintenance Window. This is used by Update Campaign to determine which Devices can be updated at a specific time. If a Device declares a Maintenance Window, the updates targeting it will start only in the interval defined by it. Note that there's no guarantee that the update will also terminate inside the Maintenance Window.","ref":"ota_update_concepts.html#maintenance-window"},{"type":"extras","title":"Base Images","doc":"As mentioned in the OTA Update concepts , Base Image is an image created to be run on a Device. The exact content of the Base Image can vary depending on the use case, but it usually contains the operating system image or the device firmware. Each Base Image belongs to a Base Image Collection . Base Images follow semantic versioning, so that the user is able to know when a specific update can contain breaking changes. Each Base Image must have a unique version number. In Edgehog a Base Image has this information associated with it: Base Image Collection: the Base Image Collection that is associated with this Base Image. Base Image URL: link to a file with the Base Image content. Version: a version number following the Semantic Versioning spec. The version number must be unique. Supported starting versions (optional): a Version Requirement that the Device must satisfy with its current Base Image to be updated with this Base Image. If a Device that does not satisfy the requirement is included in an Update Campaign that uses this Base Image, the result of the OTA Operation is an error. Release Display Name (optional): a localized user-friendly name for the release. Description (optional): a localized description of the content of the Base Image. The following sections will illustrate all the pages that can be used to list, create, edit and delete Base Images.","ref":"base_images.html"},{"type":"extras","title":"Base Images - Base Image List","doc":"The Base Image Collection page shows table with associated Base Images. Clicking on the Base Image Version brings to the Base Image page. Clicking on the &quot;Create Base Image&quot; button in the right brings to the Create Base Image page.","ref":"base_images.html#base-image-list"},{"type":"extras","title":"Base Images - Base Image","doc":"The Base Image page shows the information about a specific Base Image and allows updating some of them. Editing any field and then pressing the &quot;Update&quot; button saves the new values for the Base Image. The &quot;Delete&quot; button allows to delete the Base Image.","ref":"base_images.html#base-image"},{"type":"extras","title":"Base Images - Create Base Image","doc":"The Create Base Image page allows creating a new Base Image. The Base Image information can be provided using the form, and pressing the &quot;Create&quot; button saves the Base Image. Some information can be automatically filled in if the Base Image can be parsed by one of the supported Base Image parsers . Other than that, users are free to use whatever format they choose for the artifact that will be pushed towards the device, provided the Device is able to handle it. When you upload add Base Image in a Base Image Collection, no update is pushed towards devices, the Base Image is just uploaded in Edgehog's storage. To start pushing updates towards devices, an Update Campaign must be created. Supported Base Image parsers Base Image parsers are not implemented yet. As soon as they are implemented, this section will be populated with the supported formats.","ref":"base_images.html#create-base-image"},{"type":"extras","title":"Base Image Collections","doc":"As mentioned in the OTA Update concepts , Base Image Collection represent a set of Base Images associated with a specific System Model and, implicitly via the System Model, with a specific Hardware Type . The mapping relation between Base Image Collection and System Models is 1:1, so a Base Image Collection is associated with a single System Model and viceversa. A Base Image Collection contains all the Base Images that ran, are running or could be run on a System Model. Drawing from the bike sharing example, there would be a different Base Image Collection for, e.g., e-bikes from each specific country to handle the different speed limitations. The primary purpose of a Base Image Collection is to limit what can be installed to a System Model, preventing unintended installations, such as electric scooter firmware on an e-bike. In Edgehog a Base Image Collection has this information associated with it: Name: a user friendly name used to identify the Base Image Collection (e.g. &quot;E-Scooter OS&quot;) Handle: a machine friendly identifier for the Base Image Collection (e.g. &quot;e-scooter-os&quot;). A valid handle must begin with a lowercase letter followed by any number of lower case letters, numbers or dashes ( - ). System Model: the System Model that is associated with this Base Image Collection. Base Images: a set of Base Images associated with this Base Image Collection. The following sections will illustrate all the pages that can be used to list, create, edit and delete Base Image Collections.","ref":"base_image_collections.html"},{"type":"extras","title":"Base Image Collections - Base Image Collection List","doc":"In the base image collection list you can see the table with all Base Image Collections that are available. Clicking on the name brings to the Base Image Collection page. Clicking on the &quot;Create Base Image Collection&quot; button in the top right brings to Create Base Image Collection page.","ref":"base_image_collections.html#base-image-collection-list"},{"type":"extras","title":"Base Image Collections - Base Image Collection","doc":"The Base Image Collection page shows the information about a specific Base Image Collection and Base Images associated with it in table below. Editing any field and then pressing the &quot;Update&quot; button saves the new values for the Base Image Collection. The &quot;Create Base Image&quot; button allows adding additional Base Images to the Base Image Collection. Clicking on the Base Image Version brings to the Base Image page. The &quot;Delete&quot; button allows to delete the Base Image Collection.","ref":"base_image_collections.html#base-image-collection"},{"type":"extras","title":"Base Image Collections - Create Base Image Collection","doc":"The Create Base Image Collection page allows creating a new Base Image Collection. The Base Image Collection information can be provided using the form, and pressing the &quot;Create&quot; button saves the Base Image Collection. The System Model must be chosen from a list of available System Models using the dropdown menu.","ref":"base_image_collections.html#create-base-image-collection"},{"type":"extras","title":"Update Channels","doc":"As mentioned in the OTA Update concepts , Update Channel represents the subscription of a Device to a specific set of Base Images. To assign a Device to a specific Update Channel the device must belong to a Group and that Group has to be assigned to the Target Groups of the Update Channel. The same Base Image can be associated with multiple Update Channels. This guarantees that once testers in the beta Update Channel validate the Base Image, the exact same Base Image will be used to update devices in the default Update Channel. In Edgehog an Update Channels has this information associated with it: Name: a user friendly name used to identify the Update Channel (e.g. &quot;Beta&quot;). Handle: a machine friendly identifier for the Update Channels (e.g. &quot;beta&quot;). A valid handle must begin with a lowercase letter followed by any number of lower case letters, numbers or dashes ( - ). Target Groups: a list of groups containing Devices which will automatically get assigned to this Update Channel. A group can be associated only with a single Update Channel. To change the auto-assignment of a specific group from an Update Channel to another, the group must be removed from the previous Update Channel and then added to the new one. The following sections will illustrate all the pages that can be used to list, create, edit and delete Update Channels.","ref":"update_channels.html"},{"type":"extras","title":"Update Channels - Update Channel List","doc":"In the Update Channel list you can see the table with all Update Channels that are available. Clicking on the name brings to the Update Channel page. Clicking on the &quot;Create Update Channel&quot; button in the top right brings to Create Update Channel page.","ref":"update_channels.html#update-channel-list"},{"type":"extras","title":"Update Channels - Update Channel","doc":"The Update Channel page shows and allows updating the information about a specific Update Channel. Editing any field and then pressing the &quot;Update&quot; button saves the new values for the Update Channel. The &quot;Delete&quot; button allows to delete the Update Channel.","ref":"update_channels.html#update-channel"},{"type":"extras","title":"Update Channels - Create Update Channel","doc":"The Create Update Channel page allows creating a new Update Channel. The Update Channel information can be provided using the form, and pressing the &quot;Create&quot; button saves the Update Channel. Target Group(s) must be chosen from a list of available Groups using the dropdown menu.","ref":"update_channels.html#create-update-channel"},{"type":"extras","title":"Update Campaigns","doc":"As mentioned in the OTA Update concepts , Update Campaign is the operation that tracks the distribution of a specific Base Image to all devices belonging to an Update Channel . Note that an Update Campaign can only send updates for the same Base Image Collection , and special operations (like converting a Device from a one System Model to another) must always be done with a Manual OTA Update . The following sections will illustrate all the pages that can be used to list, create and view Update Campaigns.","ref":"update_campaigns.html"},{"type":"extras","title":"Update Campaigns - Update Campaign List","doc":"In the Update Campaign list you can see the table with all Update Campaigns. Clicking on the name brings to the Update Campaign page. Clicking on the &quot;Create Update Campaign&quot; button in the top right brings to Create Update Campaign page.","ref":"update_campaigns.html#update-campaign-list"},{"type":"extras","title":"Update Campaigns - Create Update Campaign","doc":"The Create Update Campaign page allows creating a new Update Campaign. When creating an Update Campaign, the following information must be provided Base Image: the target Base Image for the Update Campaign. Update Channel: the target Update Channel for the Update Campaign. Roll-out Mechanism properties. The Update Campaign information can be provided using the form, and pressing the &quot;Create&quot; button saves the Update Campaign. Once created, the Update Campaign will start rolling out updates towards the devices, and its progress can be checked from the Edgehog Dashboard or through Edgehog GraphQL API. Note that the campaign will &quot;snapshot&quot; the Devices belonging to the Update Channel when it's started, and will target only those. If additional Devices are added to the Update Channel (either manually or automatically via auto-assignment) after the Update Campaign is created, they won't receive the Base Image and will require a separate campaign to be started. Only a single Update Campaign can be started for a given System Model and Update Channel combination, so creating a new Update Campaign while another one is already running will implicitly cancel* the old one. This means that Devices that didn't yet receive the Base Image of the old Update Campaign will directly receive the new one, without any intermediate step. * Implicit Cancellation feature is planned for a future release Roll-out mechanism Here are the currently supported Roll-out Mechanisms and their properties push This Roll-out mechanism pushes the update towards the device unconditionally. This can be used to provide automatic updates where the user should not have the choice of refusing the update. The properties of this Roll-out Mechanism are: Max Pending Operations: the maximum number of pending OTA Operations . The Update Campaign will have at most this number of OTA Operations that are started but not yet finished (either successfully or not). Max Failures: the maximum percentage of failures allowed over the number of total targets. If the failures exceed this threshold, the Update Campaign terminates with a failure. Request Retries: the number of times an update must be retried on a specific Device before considering it a failure. Note that the update is retried only if the OTA Request doesn't get acknowledged from the device. Request Timeout: the timeout (in seconds) to wait before considering an OTA Request lost (and possibly retry). Force Downgrade (optional): when checked forces downgrading a Device which is currently using a later version of the Base Image. optional * * The Optional rollout mechanism is planned for a future release This Roll-out mechanism just pushes a message towards the Device informing that an update is available. The update is downloaded to the device only after the user accepts the update. The update is not required to be pushed immediately, to provide a backpressure mechanism if many users accept the update at the same time.","ref":"update_campaigns.html#create-update-campaign"},{"type":"extras","title":"Update Campaigns - Update Campaign","doc":"The Update Campaign page shows the information about a specific Update Campaign and Devices associated with it in table below. Clicking on the Base Image Collection, Base Image, Update Channel or Device name bring to the corresponding page.","ref":"update_campaigns.html#update-campaign"},{"type":"extras","title":"OTA Updates","doc":"Edgehog provides an OTA update mechanism that allows remotely updating devices. The OTA update mechanism is not tied to a specific platform and can be used on any Edgehog runtime which implements the io.edgehog.devicemanager.OTARequest , io.edgehog.devicemanager.OTAEvent and io.edgehog.devicemanager.BaseImage interfaces. OTA Update concepts are detailed in the dedicated page , this guide demonstrates the usage of an OTA update mechanism.","ref":"ota_updates.html"},{"type":"extras","title":"OTA Updates - Managed OTA Updates","doc":"Edgehog provides a mechanism to roll-out OTA updates to devices automatically, based on their System Model and their membership to specific Groups . To push updates towards Devices, an Update Campaign must be created. It's important to note that an Update Campaign can only send updates for the same Base Image Collection. Special operations, such as converting a Device from one System Model to another, must always be done with a Manual OTA Update . Once created, the Update Campaign will start rolling out updates towards the devices, and its progress can be checked from the Edgehog Dashboard or through Edgehog GraphQL API. Note that the campaign will &quot;snapshot&quot; the Devices belonging to the Update Channel when it's started, and will target only those. Once started, the Update Campaign waits for device to come online, at which point it initiates the OTA Update. Roll-out mechanim properties can affect this process. For example, Max Pending Operations setting may postpone some OTA Operations. Before actual push to the Device corresponding Update Target is verified for fulfillment of Base Image and Roll-out mechanism criteria. For example: Devices having same Base Image version will be silently marked as successful. Devices with Base Images that don't meet Version Requirement of distributed Base Image will be marked as failed, unless the Force Downgrade option of Push Roll-out mechanism is enabled.","ref":"ota_updates.html#managed-ota-updates"},{"type":"extras","title":"OTA Updates - Manual OTA Updates","doc":"As an escape hatch, it's always possible to manually update a Device from its page on the Edgehog dashboard (or using the Edgehog GraphQL API). Note that Manual OTA Updates do not perform any check on the System Model , so they can effectively be used to change the System Model of a Device. This also means that the user must exercise particular attention to avoid bricking a Device, if the Device does not implement the necessary safety checks.","ref":"ota_updates.html#manual-ota-updates"},{"type":"extras","title":"Architecture overview","doc":"This is an overview of Edgehog's architecture. The following sections will detail the interactions between Edgehog and the other components represented in the architecture diagram.","ref":"overview.html"},{"type":"extras","title":"Architecture overview - User interaction","doc":"Edgehog exposes two ways to interact with it: a frontend that can be used by users and a GraphQL API which can be used by third party applications to programmatically perform all actions that can be performed in the frontend. As a matter of fact, the frontend itself uses the GraphQL API to perform its tasks.","ref":"overview.html#user-interaction"},{"type":"extras","title":"Architecture overview - Database interaction","doc":"Edgehog uses PostgreSQL to store its data. The database schema supports multiple tenants which are isolated at the database level. This makes it possible to use a single Edgehog instance with multiple tenants (e.g. in a SaaS scenario).","ref":"overview.html#database-interaction"},{"type":"extras","title":"Architecture overview - Device interaction (through Astarte)","doc":"To interact with the other side of the domain (i.e. devices), Edgehog is built upon Astarte and it exchanges data with it using two of its mechanisms: its REST API and Astarte Triggers . Each Edgehog tenant is mapped to an Astarte Realm, and it owns the credentials to interact with all the Realm APIs for that specific Realm. Edgehog Astarte Interfaces The interaction between Edgehog and Astarte is defined by a set of interfaces that define which data is sent both from Edgehog to the Devices and from the Devices towards Edgehog. Additionally, connection and disconnection triggers ar installed in the Astarte Realm, and point to the triggers endpoint of the Edgehog tenant. Astarte AppEngine API The REST API is called every time Edgehog needs to retrieve data contained in an Astarte interface or when it needs to send data to the Devices. In the first case, Edgehog issues a GET HTTP request to retrieve the data from AppEngine API, which reads the data from the Astarte database. When Edgehog needs to send data towards a Device instead, it sends a POST HTTP to AppEngine API, which takes care of delivering data via MQTT to the device. Astarte Triggers Astarte Triggers are used to update the online state of the device. Each time a Device connects or disconnects from Astarte, Astarte Trigger Engine sends an HTTP POST request to the Edgehog backend, which in turn updates the Device online status in its own database.","ref":"overview.html#device-interaction-through-astarte"},{"type":"extras","title":"Deploying with Kubernetes","doc":"Edgehog was designed as a Kubernetes native application, this guide will show how to deploy an Edgehog instance in a Kubernetes cluster. Note: currently Edgehog requires some manual initialization operations to be performed in the Elixir interactive shell and is not completely automated. All required operations are detailed below in the guide.","ref":"deploying_with_kubernetes.html"},{"type":"extras","title":"Deploying with Kubernetes - Requirements","doc":"A Kubernetes cluster kubectl correctly configured to target the aforementioned cluster An Ingress Controller deployed in the cluster (the guide contains examples for the NGINX Ingress Controller) An Astarte instance, with an existing realm and its private key A PostgreSQL database S3-compatible storage with its credentials The jq utility installed in the system (Optional) A Google Geolocation API Key (Optional) A Google Geocoding API Key (Optional) An ipbase.com API Key The guide does not cover in detail how Edgehog is exposed to the internet, since administrators are free to use their favorite Ingress Controller to achieve that. An example Ingress using the NGINX Ingress Controller is provided, but advanced operations (e.g. certificate management) are out of the scope of this guide. The guide assumes everything is deployed to the edgehog namespace in the Kubernetes cluster, but Edgehog can be deployed in any namespace adjusting the yaml files and the commands accordingly. All fields that have to be customized will be indicated &lt;WITH-THIS-SYNTAX&gt; .","ref":"deploying_with_kubernetes.html#requirements"},{"type":"extras","title":"Deploying with Kubernetes - Deploying Edgehog","doc":"This part of the guide will detail all the operations to deploy Edgehog into an existing Kubernetes cluster. Namespace First of all, the edgehog namespace has to be created $ kubectl create namespace edgehog Installing NGINX Ingress Controller and cert-manager (example) At this point you should install an Ingress Controller in your cluster. As an example, we will show the procedure to install the NGINX Ingress Controller and cert-manager (to manager SSL certificates) using helm . To do so, use these commands $ helm repo add jetstack https://charts.jetstack.io $ helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx $ helm repo update $ helm install cert-manager jetstack/cert-manager \\ --create-namespace --namespace cert-manager --set installCRDs=true $ helm upgrade --install ingress-nginx ingress-nginx/ingress-nginx \\ --create-namespace --namespace ingress-nginx After some minutes, you can retrieve the Load Balancer IP with $ kubectl get svc -n ingress-nginx in the EXTERNAL-IP column. Note that NGINX is only one of the possible Ingress Controllers, instructions for other Ingress Controllers are outside the scope of this guide. Creating DNS entries Once you have the Load Balancer IP (obtained in the previous step ), head to your DNS provider and point two domains (one for the backend and one for the frontend) to that IP address. Save the two hosts (e.g. api.edgehog.example.com and edgehog.example.com ) since they're going to be needed for the following steps. Secrets A series of secrets containing various credentials have to be created. Database connection This command creates the secret containing the details for the database connection: $ kubectl create secret generic -n edgehog edgehog-db-connection \\ --from-literal=&quot;database=&lt;DATABASE-NAME&gt;&quot; \\ --from-literal=&quot;username=&lt;DATABASE-USER&gt;&quot; \\ --from-literal=&quot;password=&lt;DATABASE-PASSWORD&gt;&quot; Values to be replaced DATABASE-NAME : the name of the PostgreSQL database. DATABASE-USER : the username to access the database. DATABASE-PASSWORD : the password to access the database. Secret key base This command creates the secret key base used by Phoenix: $ kubectl create secret generic -n edgehog edgehog-secret-key-base \\ --from-literal=&quot;secret-key-base=$(openssl rand -base64 48)&quot; S3 Credentials (Google Cloud) To create an S3-compatbile bucket on Google Cloud to be used with Edgehog, the following steps have to be performed: Create a service account in your project. Create JSON credentials for the service account and rewrite them as a single line JSON: $ gcloud iam service-accounts keys create service_account_credentials.json \\ --iam-account=&lt;SERVICE-ACCOUNT-EMAIL&gt; $ cat service_account_credentials.json | jq -c &gt; s3_credentials.json Create a Cloud Storage Bucket on GCP Choose a multiregion in the preferred zones (e.g. Europe) Remove public access prevention Choose a fine-grained Access Control, instead of a uniform one After making sure of having the right project selected for the gcloud CLI, assign the objectAdmin permission to the service account for the newly created bucket: $ gsutil iam ch serviceAccount:&lt;SERVICE-ACCOUNT-EMAIL&gt;:objectAdmin gs://&lt;BUCKET-NAME&gt; Create a secret containing the service account credentials $ kubectl create secret generic -n edgehog edgehog-s3-credentials \\ --from-file=&quot;gcp-credentials=s3_credentials.json&quot; Values to be replaced SERVICE-ACCOUNT-EMAIL : the email associated with the service account. BUCKET-NAME : the bucket name for the S3 storage. S3 Credentials (Generic) Consult the documentation of your cloud provider for more details about obtaining an access key ID and a secret access key for your S3-compatible storage. This command creates the secret containing the S3 credentials: $ kubectl create secret generic -n edgehog edgehog-s3-credentials \\ --from-literal=&quot;access-key-id=&lt;ACCESS-KEY-ID&gt;&quot; \\ --from-literal=&quot;secret-access-key=&lt;SECRET-ACCESS-KEY&gt;&quot; Values to be replaced ACCESS-KEY-ID : the access key ID for your S3 storage. SECRET-ACCESS-KEY : the secret access key for your S3 storage. Google Geolocation API Key (optional) Activate the Geolocation API for your project in GCP and create an API key to be used with Google Geolocation. After that, create the secret containing the API key with: $ kubectl create secret generic -n edgehog edgehog-google-geolocation-credentials \\ --from-literal=&quot;api-key=&lt;API-KEY&gt;&quot; \\ Values to be replaced API-KEY : the Google Geolocation API Key obtained from GCP. Google Geocoding API Key (optional) Activate the Geocoding API for your project in GCP and create an API key to be used with Google Geocoding. After that, create the secret containing the API key with: $ kubectl create secret generic -n edgehog edgehog-google-geocoding-credentials \\ --from-literal=&quot;api-key=&lt;API-KEY&gt;&quot; Values to be replaced API-KEY : the Google Geocoding API Key obtained from GCP. ipbase.com API Key (optional) Register an account at ipbase.com to obtain an API key. After that, create the secret containing the API key with: $ kubectl create secret generic -n edgehog edgehog-ipbase-credentials \\ --from-literal=&quot;api-key=&lt;API-KEY&gt;&quot; Values to be replaced API-KEY : the API Key obtained from ipbase.com. Deployments After secrets are deployed, the deployments can be applied to the cluster. Backend To deploy the backend, copy the following yaml snippet in backend-deployment.yaml , fill the missing values (detailed below) and execute $ kubectl apply -f backend-deployment.yaml apiVersion: apps/v1 kind: Deployment metadata: labels: app: edgehog-backend name: edgehog-backend namespace: edgehog spec: replicas: 1 selector: matchLabels: app: edgehog-backend template: metadata: labels: app: edgehog-backend spec: containers: - env: - name: RELEASE_NAME value: edgehog - name: PORT value: &quot;4000&quot; - name: URL_HOST value: &lt;BACKEND-HOST&gt; - name: DATABASE_HOSTNAME value: &lt;DATABASE-HOSTNAME&gt; - name: DATABASE_NAME valueFrom: secretKeyRef: key: database name: edgehog-db-connection - name: DATABASE_USERNAME valueFrom: secretKeyRef: key: username name: edgehog-db-connection - name: DATABASE_PASSWORD valueFrom: secretKeyRef: key: password name: edgehog-db-connection - name: SECRET_KEY_BASE valueFrom: secretKeyRef: key: secret-key-base name: edgehog-secret-key-base - name: MAX_UPLOAD_SIZE_BYTES value: &quot;&lt;MAX-UPLOAD-SIZE-BYTES&gt;&quot; # Uncomment this env if you have installed an optional ipbase.com API Key in the secrets # #- name: IPBASE_API_KEY # valueFrom: # secretKeyRef: # key: api-key # name: edgehog-ipbase-credentials # Uncomment this env if you have installed an optional Google Geolocation API Key in the # secrets # #- name: GOOGLE_GEOLOCATION_API_KEY # valueFrom: # secretKeyRef: # key: api-key # name: edgehog-google-geolocation-credentials # Uncomment these envs if you have installed an optional Google Geocoding API Key in # the secrets #- name: GOOGLE_GEOCODING_API_KEY # valueFrom: # secretKeyRef: # key: api-key # name: edgehog-google-geocoding-credentials - name: S3_GCP_CREDENTIALS valueFrom: secretKeyRef: key: gcp-credentials name: edgehog-s3-credentials # If you're using another S3 provider which is not Google Cloud, uncomment these envs and # delete the previous env # #- name: S3_ACCESS_KEY_ID # valueFrom: # secretKeyRef: # key: access-key-id # name: edgehog-s3-credentials #- name: S3_SECRET_ACCESS_KEY # valueFrom: # secretKeyRef: # key: secret-access-key # name: edgehog-s3-credentials - name: S3_SCHEME value: &lt;S3-SCHEME&gt; - name: S3_HOST value: &lt;S3-HOST&gt; - name: S3_PORT value: &quot;&lt;S3-PORT&gt;&quot; - name: S3_BUCKET value: &lt;S3-BUCKET&gt; - name: S3_ASSET_HOST value: &lt;S3-ASSET-HOST&gt; - name: S3_REGION value: &lt;S3-REGION&gt; image: edgehogdevicemanager/edgehog-backend:snapshot imagePullPolicy: Always name: edgehog-backend ports: - containerPort: 4000 name: http protocol: TCP Values to be replaced BACKEND-HOST : the host of the Edgehog backend (see the Creating DNS entries section). DATABASE-HOSTNAME : the hostname of the PostgreSQL database. MAX-UPLOAD-SIZE-BYTES : the maximum dimension for uploads, particularly relevant for OTA updates. If omitted, it defaults to 4 Gigabytes. S3-SCHEME : the scheme ( http or https ) for the S3 storage. S3-HOST : the host for the S3 storage. S3-PORT : the port for the S3 storage. This has to be put in double quotes to force it to be interpreted as a string. S3-BUCKET : the bucket name for the S3 storage. S3-ASSET-HOST : the asset host for the S3 storage, e.g. storage.googleapis.com/&lt;S3-BUCKET&gt; for GCP or &lt;S3-BUCKET&gt;.s3.amazonaws.com for AWS. S3-REGION : the region where the S3 storage resides. The optional env variable in the yaml also have to be uncommented where relevant (see comments above the commented blocks for more information). Frontend To deploy the frontend, copy the following yaml snippet in frontend-deployment.yaml , fill the missing values (detailed below) and execute $ kubectl apply -f frontend-deployment.yaml apiVersion: apps/v1 kind: Deployment metadata: labels: app: edgehog-frontend name: edgehog-frontend namespace: edgehog spec: replicas: 1 selector: matchLabels: app: edgehog-frontend template: metadata: labels: app: edgehog-frontend spec: containers: - env: - name: BACKEND_URL value: &lt;BACKEND-HOST&gt; image: edgehogdevicemanager/edgehog-frontend:snapshot imagePullPolicy: Always name: edgehog-frontend ports: - containerPort: 80 name: httpout protocol: TCP Values to be replaced BACKEND-URL : the API base URL of the Edgehog backend (see the Creating DNS entries section). This should be, e.g., https://&lt;BACKEND-HOST&gt; . Services Backend To deploy the backend service, copy the following yaml snippet in backend-service.yaml and execute $ kubectl apply -f backend-service.yaml apiVersion: v1 kind: Service metadata: labels: app: edgehog-backend name: edgehog-backend namespace: edgehog spec: ports: - port: 4000 protocol: TCP targetPort: 4000 selector: app: edgehog-backend Frontend To deploy the frontend service, copy the following yaml snippet in frontend-service.yaml and execute $ kubectl apply -f frontend-service.yaml apiVersion: v1 kind: Service metadata: labels: app: edgehog-frontend name: edgehog-frontend namespace: edgehog spec: ports: - port: 80 protocol: TCP targetPort: 80 selector: app: edgehog-frontend Exposing Edgehog to the Internet SSL Certificates This is an example certificates configuration for Edgehog. This is provided as a starting point and it uses certmanager to obtain LetsEncrypt SSL certificates. All advanced topics (advanced certificate management, self-provided certificates) are not discussed here and are outside the scope of this guide. First of all, create a ClusterIssuer by copying the following yaml snippet in cluster-issuer.yaml and executing $ kubectl apply -f cluster-issuer.yaml apiVersion: cert-manager.io/v1 kind: ClusterIssuer metadata: name: letsencrypt spec: acme: server: https://acme-v02.api.letsencrypt.org/directory email: &lt;EMAIL-ADDRESS&gt; privateKeySecretRef: name: letsencrypt solvers: - http01: ingress: class: nginx Values to be replaced EMAIL-ADDRESS : a valid email address that will be used for the ACME account for LetsEncrypt. After that, create a certificate for your frontend and backend hosts, copying the following yaml snippet in certificate.yaml and executing $ kubectl apply -f certificate.yaml apiVersion: cert-manager.io/v1 kind: Certificate metadata: name: tls-secret namespace: edgehog spec: secretName: tls-secret dnsNames: - &lt;FRONTEND-HOST&gt; - &lt;BACKEND-HOST&gt; issuerRef: group: cert-manager.io kind: ClusterIssuer name: letsencrypt Values to be replaced FRONTEND-HOST : the frontend host. BACKEND-HOST : the backend host. Note that this step must be performed after DNS for the frontend and backend hosts are correctly propagated (see Creating DNS Entries ). Ingress This is an example Ingress configuration for Edgehog. This is provided as a starting point and it uses the NGINX Ingress Controller. All advanced topics (e.g. certificate management) are not discussed here and are outside the scope of this guide. Copy this yaml snippet to ingress.yaml and execute $ kubectl apply -f ingress.yaml apiVersion: networking.k8s.io/v1 kind: Ingress metadata: annotations: cert-manager.io/cluster-issuer: letsencrypt kubernetes.io/ingress.class: nginx nginx.ingress.kubernetes.io/proxy-body-size: &lt;MAX-UPLOAD-SIZE&gt; name: edgehog-ingress namespace: edgehog spec: rules: - host: &lt;FRONTEND-HOST&gt; http: paths: - backend: service: name: edgehog-frontend port: number: 80 path: / pathType: Prefix - host: &lt;BACKEND-HOST&gt; http: paths: - backend: service: name: edgehog-backend port: number: 4000 path: / pathType: Prefix tls: - hosts: - &lt;FRONTEND-HOST&gt; - &lt;BACKEND-HOST&gt; secretName: tls-secret Values to be replaced FRONTEND-HOST : the frontend host. BACKEND-HOST : the backend host. MAX-UPLOAD-SIZE : the maximum upload size that you defined in the Edgehog backend deployment . Note that NGINX accepts also size suffixes, so you can put, e.g., 4G for 4 gigabytes. Also note that, differently from the value in the Deployment, this is required because NGINX default is 1 megabyte.","ref":"deploying_with_kubernetes.html#deploying-edgehog"},{"type":"extras","title":"Deploying with Kubernetes - Edgehog Initialization","doc":"These are some manual operation that have to be performed to initialize the Edgehog instance. In the future these operation will be automated and/or will be performed using a dedicated API. Creating a keypair A keypair is needed to emit and validate tokens to access your tenant. You can generate an EC keypair with the following OpenSSL commands $ openssl ecparam -name prime256v1 -genkey -noout &gt; private_key.pem $ openssl ec -in private_key.pem -pubout &gt; public_key.pem After those commands are executed, you will have two files: private_key.pem and public_key.pem . The content of public_key.pem will be needed in the next steps, while private_key.pem will be used to emit Edgehog tokens. Make sure to store the private key somewhere safe. Connecting to iex Connect to the iex interactive shell of the Edgehog backend using $ kubectl exec -it deploy/edgehog-backend -n edgehog -- /app/bin/edgehog remote All the following commands have to be executed inside that shell, in a single session (since some commands will reuse the result of previous commands) Creating the tenant The following commands will create a database entry representing the tenant, with its associated Astarte cluster and Realm. iex&gt; alias Edgehog.Provisioning iex&gt; tenant_name = &quot;&lt;TENANT-NAME&gt;&quot; iex&gt; tenant_slug = &quot;&lt;TENANT-SLUG&gt;&quot; iex&gt; tenant_public_key = &quot;&quot;&quot; &lt;TENANT-PUBLIC-KEY&gt; &quot;&quot;&quot; iex&gt; base_api_url = &quot;&lt;ASTARTE-BASE-API-URL&gt;&quot; iex&gt; realm_name = &quot;&lt;ASTARTE-REALM-NAME&gt;&quot; iex&gt; realm_private_key = &quot;&quot;&quot; &lt;ASTARTE-REALM-PRIVATE-KEY&gt; &quot;&quot;&quot; iex&gt; { :ok , tenant } = Provisioning . provision_tenant ( %{ name : tenant_name , slug : tenant_slug , public_key : tenant_public_key , astarte_config : %{ base_api_url : base_api_url , realm_name : realm_name , realm_private_key : realm_private_key } } ) Values to be replaced TENANT-NAME : the name of the new tenant. TENANT-SLUG : the slug of the tenant, must contain only lowercase letters and hyphens. TENANT-PUBLIC-KEY : the content of public_key.pem created in the previous step . Open a multiline string with &quot;&quot;&quot; , press Enter, paste the content of the file in the iex shell and then close the multiline string with &quot;&quot;&quot; on a new line. ASTARTE-BASE-API-URL : the base API url of the Astarte instance (e.g. https://api.astarte.example.com ). ASTARTE-REALM-NAME : the name of the Astarte realm you're using. ASTARTE-REALM-PRIVATE-KEY : the content of you realm's private key. Open a multiline string with &quot;&quot;&quot; , press Enter, paste the content of the file in the iex shell and then close the multiline string with &quot;&quot;&quot; on a new line. Accessing Edgehog At this point your Edgehog instance is ready to use. The last step is generating a token to access your Edgehog frontend instance. You can do so using the gen-edgehog-jwt tool contained in the tools directory of the Edgehog repo . $ pip3 install pyjwt $ ./gen-edgehog-jwt -k &lt;PATH-TO-TENANT-PRIVATE-KEY&gt; Values to be replaced PATH-TO-TENANT-PRIVATE-KEY : path to the private_key.pem file created in the previous step . Note that the token expires after 24 hours by default. If you want to have a token with a different expiry time, you can pass -e &lt;EXPIRY-SECONDS&gt; to the gen-edgehog-jwt command. After that, you can open your frontend URL in your browser and insert your tenant slug and token to log into your Edgehog instance, and use to the user guide to discover all Edgehog features.","ref":"deploying_with_kubernetes.html#edgehog-initialization"},{"type":"extras","title":"Interacting with Edgehog","doc":"Edgehog's interaction is logically divided amongst two main entities: devices and users. Devices are the bottom end, and represent the IoT fleet. They can access Astarte and exchange data via Astarte Interfaces which, in turn, also define on a very granular level which kind of data they can exchange. Data exposed by devices are relayed to Edgehog via Astarte Triggers. Users are actual users, applications or anything else which needs to interact with Edgehog.","ref":"interacting_with_edgehog.html"},{"type":"extras","title":"Interacting with Edgehog - User-side Tools","doc":"To interact with Edgehog, several options are available: Edgehog's dashboard interface: it provides a built-in UI that can be used for managing Devices, Hardware Types, and System Models. It is meant to be a graphical, user-friendly tool to manage those entities. Edgehog's GraphQL APIs : they are meant as a machine-friendly way to perform operations on Edgehog's entities and for integrating 3rd party applications.","ref":"interacting_with_edgehog.html#user-side-tools"},{"type":"extras","title":"Interacting with Edgehog - Publishing Device data","doc":"Devices can publish any kind of data to Astarte via Astarte Interfaces. However, some standard interfaces are already supported by Edgehog in order to provide useful functionalities, such as device geolocation. Hence, data that devices send via Edgehog's Astarte Interfaces are automatically understood, collected and reported by Edgehog. Publishing info about the System Each Device is supposed to notify Astarte, e.g. on each connection, about its System. To do so, the Device can use the io.edgehog.devicemanager.SystemInfo Astarte Interface to specify: the Serial Number: a code that uniquely identifies the System the Part Number: a code that uniquely identifies the System Model When exposing the Part Number, Edgehog can associate the Device to the correct System Model by matching the Device's Part Number with the ones of the registered System Model. Publishing info about the hardware Each Device can notify Astarte about the general capabilities of the Device. These info are hardware-related and are usually not intended to change over time. A Device can expose this set of data via the io.edgehog.devicemanager.HardwareInfo Astarte Interface. Publishing info about the Device status To expose info about its current status or measured data, some additional Astarte Interfaces are already defined for Edgehog. Their adoption is optional but recommended. io.edgehog.devicemanager.SystemStatus : reports the current OS status. io.edgehog.devicemanager.StorageUsage : reports the capacity and usage of the storage units. io.edgehog.devicemanager.BatteryStatus : reports the current status of the battery slots. io.edgehog.devicemanager.Geolocation : reports the current position computed by the GPS sensors of the device. io.edgehog.devicemanager.WiFiScanResults : reports the list of nearby Access Points that the Device found while scanning for WiFi signals.","ref":"interacting_with_edgehog.html#publishing-device-data"},{"type":"extras","title":"Astarte Interfaces","doc":"","ref":"astarte_interfaces.html"},{"type":"extras","title":"Astarte Interfaces - io.edgehog.devicemanager.BaseImage v0.1","doc":"About This interface is of type properties and is owned by the device , meaning that it is the device which initiates the data flow. Thanks to this type of interface, the device can set a persistent, stateful, synchronized state with no concept of history or timestamping. Mappings The interface has the following mappings: /fingerprint with string type. OS bundle release identification code /name with string type. Name of the bundle /version with string type. Version of the bundle /buildId with string type. Human readable build identifier. Examples are [date][time] or [date]-[time]-[git-commit] /fingerprint OS bundle release identification code This endpoint accepts values of type string : an UTF-8 string, at most 65536 bytes long. The value of the property cannot be unset. /name Name of the bundle This endpoint accepts values of type string : an UTF-8 string, at most 65536 bytes long. The value of the property cannot be unset. /version Version of the bundle This endpoint accepts values of type string : an UTF-8 string, at most 65536 bytes long. The value of the property cannot be unset. /buildId Human readable build identifier. Examples are [date][time] or [date]-[time]-[git-commit] This endpoint accepts values of type string : an UTF-8 string, at most 65536 bytes long. The value of the property cannot be unset.","ref":"astarte_interfaces.html#io-edgehog-devicemanager-baseimage-v0-1"},{"type":"extras","title":"Astarte Interfaces - io.edgehog.devicemanager.BatteryStatus v0.1","doc":"About This interface is of type datastream and is owned by the device , meaning that it is the device which initiates the data flow. Thanks to this type of interface, the device can send a mutable, ordered stream of data, with no concept of persistent state or synchronization. Data gets sent with an object aggregation. Astarte expects the owner to send all of the interface's mappings at the same time, packed in a single message. Mappings The interface has the following mappings: /%{battery_slot}/levelPercentage with double type. Battery level estimated percentage [0.0%-100.0%] /%{battery_slot}/levelAbsoluteError with double type. Battery level measurement absolute error [0.0-100.0] /%{battery_slot}/status with string type. Battery status string, any of: Charging, Discharging, Idle, EitherIdleOrCharging, Failure, Removed, Unknown /%{battery_slot}/levelPercentage Battery level estimated percentage [0.0%-100.0%] This endpoint accepts values of type double : a double-precision floating-point number as specified by binary64, by the IEEE 754 standard. The endpoint is parametric and battery_slot can be replaced with any valid string to send data on specialized paths. The endpoint has a specific configuration for how data is stored, transferred and indexed. Astarte expects a valid timestamp to be attached each time data is produced. Data is considered delivered when the transport successfully sends the data regardless of the outcome. Data is discarded if the transport is temporarily uncapable of delivering it. Delivered data is kept for 5184000 seconds before it is erased from the database. /%{battery_slot}/levelAbsoluteError Battery level measurement absolute error [0.0-100.0] This endpoint accepts values of type double : a double-precision floating-point number as specified by binary64, by the IEEE 754 standard. The endpoint is parametric and battery_slot can be replaced with any valid string to send data on specialized paths. The endpoint has a specific configuration for how data is stored, transferred and indexed. Astarte expects a valid timestamp to be attached each time data is produced. Data is considered delivered when the transport successfully sends the data regardless of the outcome. Data is discarded if the transport is temporarily uncapable of delivering it. Delivered data is kept for 5184000 seconds before it is erased from the database. /%{battery_slot}/status Battery status string, any of: Charging, Discharging, Idle, EitherIdleOrCharging, Failure, Removed, Unknown This endpoint accepts values of type string : an UTF-8 string, at most 65536 bytes long. The endpoint is parametric and battery_slot can be replaced with any valid string to send data on specialized paths. The endpoint has a specific configuration for how data is stored, transferred and indexed. Astarte expects a valid timestamp to be attached each time data is produced. Data is considered delivered when the transport successfully sends the data regardless of the outcome. Data is discarded if the transport is temporarily uncapable of delivering it. Delivered data is kept for 5184000 seconds before it is erased from the database.","ref":"astarte_interfaces.html#io-edgehog-devicemanager-batterystatus-v0-1"},{"type":"extras","title":"Astarte Interfaces - io.edgehog.devicemanager.CellularConnectionProperties v0.1","doc":"About This interface is of type properties and is owned by the device , meaning that it is the device which initiates the data flow. Thanks to this type of interface, the device can set a persistent, stateful, synchronized state with no concept of history or timestamping. Mappings The interface has the following mappings: /%{id}/apn with string type. Operator apn address. /%{id}/imei with string type. The modem IMEI code of the device. /%{id}/imsi with string type. The SIM IMSI code of the device. /%{id}/apn Operator apn address. This endpoint accepts values of type string : an UTF-8 string, at most 65536 bytes long. The endpoint is parametric and id can be replaced with any valid string to send data on specialized paths. The value of the property can be unset. /%{id}/imei The modem IMEI code of the device. This endpoint accepts values of type string : an UTF-8 string, at most 65536 bytes long. The endpoint is parametric and id can be replaced with any valid string to send data on specialized paths. The value of the property can be unset. /%{id}/imsi The SIM IMSI code of the device. This endpoint accepts values of type string : an UTF-8 string, at most 65536 bytes long. The endpoint is parametric and id can be replaced with any valid string to send data on specialized paths. The value of the property can be unset.","ref":"astarte_interfaces.html#io-edgehog-devicemanager-cellularconnectionproperties-v0-1"},{"type":"extras","title":"Astarte Interfaces - io.edgehog.devicemanager.CellularConnectionStatus v0.1","doc":"About This interface is of type datastream and is owned by the device , meaning that it is the device which initiates the data flow. Thanks to this type of interface, the device can send a mutable, ordered stream of data, with no concept of persistent state or synchronization. Data gets sent with an object aggregation. Astarte expects the owner to send all of the interface's mappings at the same time, packed in a single message. Mappings The interface has the following mappings: /%{id}/carrier with string type. Connectivity carrier operator name. /%{id}/cellId with longinteger type. The Cell ID in hexadecimal format, either 16 bit for 2G or 28 bit for 3G or 4G. /%{id}/mobileCountryCode with integer type. The mobile country code (MCC) for the device's home network. Valid range: 0–999. /%{id}/mobileNetworkCode with integer type. The Mobile Network Code for the device's home network. This is the MNC for GSM, WCDMA, LTE and NR. CDMA uses the System ID (SID). Valid range for MNC: 0–999. Valid range for SID: 0–32767. /%{id}/localAreaCode with integer type. Two byte location area code in hexadecimal format. /%{id}/registrationStatus with string type. GSM/LTE registration status. Possible values: [NotRegistered, Registered, SearchingOperator, RegistrationDenied, Unknown, RegisteredRoaming] /%{id}/rssi with double type. Signal strenght of the device in dBm. /%{id}/technology with string type. Access Technology. Possible values [GSM, GSMCompact, UTRAN, GSMwEGPRS, UTRANwHSDPA, UTRANwHSUPA, UTRANwHSDPAandHSUPA, EUTRAN] /%{id}/carrier Connectivity carrier operator name. This endpoint accepts values of type string : an UTF-8 string, at most 65536 bytes long. The endpoint is parametric and id can be replaced with any valid string to send data on specialized paths. The endpoint has a specific configuration for how data is stored, transferred and indexed. Astarte expects a valid timestamp to be attached each time data is produced. Data is considered delivered when the transport successfully sends the data regardless of the outcome. Data is discarded if the transport is temporarily uncapable of delivering it. Delivered data is kept for 5184000 seconds before it is erased from the database. /%{id}/cellId The Cell ID in hexadecimal format, either 16 bit for 2G or 28 bit for 3G or 4G. This endpoint accepts values of type longinteger : a signed 64 bit integer (please note that longinteger is represented as a string by default in JSON-based APIs.). The endpoint is parametric and id can be replaced with any valid string to send data on specialized paths. The endpoint has a specific configuration for how data is stored, transferred and indexed. Astarte expects a valid timestamp to be attached each time data is produced. Data is considered delivered when the transport successfully sends the data regardless of the outcome. Data is discarded if the transport is temporarily uncapable of delivering it. Delivered data is kept for 5184000 seconds before it is erased from the database. /%{id}/mobileCountryCode The mobile country code (MCC) for the device's home network. Valid range: 0–999. This endpoint accepts values of type integer : a signed 32 bit integer. The endpoint is parametric and id can be replaced with any valid string to send data on specialized paths. The endpoint has a specific configuration for how data is stored, transferred and indexed. Astarte expects a valid timestamp to be attached each time data is produced. Data is considered delivered when the transport successfully sends the data regardless of the outcome. Data is discarded if the transport is temporarily uncapable of delivering it. Delivered data is kept for 5184000 seconds before it is erased from the database. /%{id}/mobileNetworkCode The Mobile Network Code for the device's home network. This is the MNC for GSM, WCDMA, LTE and NR. CDMA uses the System ID (SID). Valid range for MNC: 0–999. Valid range for SID: 0–32767. This endpoint accepts values of type integer : a signed 32 bit integer. The endpoint is parametric and id can be replaced with any valid string to send data on specialized paths. The endpoint has a specific configuration for how data is stored, transferred and indexed. Astarte expects a valid timestamp to be attached each time data is produced. Data is considered delivered when the transport successfully sends the data regardless of the outcome. Data is discarded if the transport is temporarily uncapable of delivering it. Delivered data is kept for 5184000 seconds before it is erased from the database. /%{id}/localAreaCode Two byte location area code in hexadecimal format. This endpoint accepts values of type integer : a signed 32 bit integer. The endpoint is parametric and id can be replaced with any valid string to send data on specialized paths. The endpoint has a specific configuration for how data is stored, transferred and indexed. Astarte expects a valid timestamp to be attached each time data is produced. Data is considered delivered when the transport successfully sends the data regardless of the outcome. Data is discarded if the transport is temporarily uncapable of delivering it. Delivered data is kept for 5184000 seconds before it is erased from the database. /%{id}/registrationStatus GSM/LTE registration status. Possible values: [NotRegistered, Registered, SearchingOperator, RegistrationDenied, Unknown, RegisteredRoaming] This endpoint accepts values of type string : an UTF-8 string, at most 65536 bytes long. The endpoint is parametric and id can be replaced with any valid string to send data on specialized paths. The endpoint has a specific configuration for how data is stored, transferred and indexed. Astarte expects a valid timestamp to be attached each time data is produced. Data is considered delivered when the transport successfully sends the data regardless of the outcome. Data is discarded if the transport is temporarily uncapable of delivering it. Delivered data is kept for 5184000 seconds before it is erased from the database. /%{id}/rssi Signal strenght of the device in dBm. This endpoint accepts values of type double : a double-precision floating-point number as specified by binary64, by the IEEE 754 standard. The endpoint is parametric and id can be replaced with any valid string to send data on specialized paths. The endpoint has a specific configuration for how data is stored, transferred and indexed. Astarte expects a valid timestamp to be attached each time data is produced. Data is considered delivered when the transport successfully sends the data regardless of the outcome. Data is discarded if the transport is temporarily uncapable of delivering it. Delivered data is kept for 5184000 seconds before it is erased from the database. /%{id}/technology Access Technology. Possible values [GSM, GSMCompact, UTRAN, GSMwEGPRS, UTRANwHSDPA, UTRANwHSUPA, UTRANwHSDPAandHSUPA, EUTRAN] This endpoint accepts values of type string : an UTF-8 string, at most 65536 bytes long. The endpoint is parametric and id can be replaced with any valid string to send data on specialized paths. The endpoint has a specific configuration for how data is stored, transferred and indexed. Astarte expects a valid timestamp to be attached each time data is produced. Data is considered delivered when the transport successfully sends the data regardless of the outcome. Data is discarded if the transport is temporarily uncapable of delivering it. Delivered data is kept for 5184000 seconds before it is erased from the database.","ref":"astarte_interfaces.html#io-edgehog-devicemanager-cellularconnectionstatus-v0-1"},{"type":"extras","title":"Astarte Interfaces - io.edgehog.devicemanager.Commands v0.1","doc":"About This interface is of type datastream and is owned by the server , meaning that it is the server which initiates the data flow. Thanks to this type of interface, the server can send a mutable, ordered stream of data, with no concept of persistent state or synchronization. Data gets sent with an individual aggregation. Each mapping is treated as an independent value and is managed individually. Mappings The interface has the following mappings: /request with string type. Command request. Possible values ['Reboot'] /request Command request. Possible values ['Reboot'] This endpoint accepts values of type string : an UTF-8 string, at most 65536 bytes long. The endpoint has a specific configuration for how data is stored, transferred and indexed. Astarte expects a valid timestamp to be attached each time data is produced. Data is considered delivered when it has been received exactly once by the recipient. Data is discarded if the transport is temporarily uncapable of delivering it.","ref":"astarte_interfaces.html#io-edgehog-devicemanager-commands-v0-1"},{"type":"extras","title":"Astarte Interfaces - io.edgehog.devicemanager.ForwarderSessionRequest v0.1","doc":"Configuration to open a session with the Edgehog Forwarder from a device to a certain host. About This interface is of type datastream and is owned by the server , meaning that it is the server which initiates the data flow. Thanks to this type of interface, the server can send a mutable, ordered stream of data, with no concept of persistent state or synchronization. Data gets sent with an object aggregation. Astarte expects the owner to send all of the interface's mappings at the same time, packed in a single message. Mappings The interface has the following mappings: /request/session_token with string type. The session token thanks to which the device can authenticates itself through Edgehog. /request/port with integer type. The host port the device must connect to. /request/host with string type. The IP address or host name the device must connect to. /request/secure with boolean type. Indicates whether the connection should use TLS, i.e. 'ws' or 'wss' scheme. /request/session_token The session token thanks to which the device can authenticates itself through Edgehog. This endpoint accepts values of type string : an UTF-8 string, at most 65536 bytes long. The endpoint has a specific configuration for how data is stored, transferred and indexed. Data is considered delivered when the transport successfully sends the data regardless of the outcome. Data is discarded if the transport is temporarily uncapable of delivering it. Delivered data is kept for 31556952 seconds before it is erased from the database. /request/port The host port the device must connect to. This endpoint accepts values of type integer : a signed 32 bit integer. The endpoint has a specific configuration for how data is stored, transferred and indexed. Data is considered delivered when the transport successfully sends the data regardless of the outcome. Data is discarded if the transport is temporarily uncapable of delivering it. Delivered data is kept for 31556952 seconds before it is erased from the database. /request/host The IP address or host name the device must connect to. This endpoint accepts values of type string : an UTF-8 string, at most 65536 bytes long. The endpoint has a specific configuration for how data is stored, transferred and indexed. Data is considered delivered when the transport successfully sends the data regardless of the outcome. Data is discarded if the transport is temporarily uncapable of delivering it. Delivered data is kept for 31556952 seconds before it is erased from the database. /request/secure Indicates whether the connection should use TLS, i.e. 'ws' or 'wss' scheme. This endpoint accepts values of type boolean : either true or false, adhering to JSON boolean type. The endpoint has a specific configuration for how data is stored, transferred and indexed. Data is considered delivered when the transport successfully sends the data regardless of the outcome. Data is discarded if the transport is temporarily uncapable of delivering it. Delivered data is kept for 31556952 seconds before it is erased from the database.","ref":"astarte_interfaces.html#io-edgehog-devicemanager-forwardersessionrequest-v0-1"},{"type":"extras","title":"Astarte Interfaces - io.edgehog.devicemanager.ForwarderSessionState v0.1","doc":"Information provided by the device about the status of a forwarder session. About This interface is of type properties and is owned by the device , meaning that it is the device which initiates the data flow. Thanks to this type of interface, the device can set a persistent, stateful, synchronized state with no concept of history or timestamping. Mappings The interface has the following mappings: /%{session_token}/status with string type. Indicates if the device is connecting, or connected to a forwarder session. /%{session_token}/status Indicates if the device is connecting, or connected to a forwarder session. An enum with the following possible values: Connecting | Connected. This endpoint accepts values of type string : an UTF-8 string, at most 65536 bytes long. The endpoint is parametric and session_token can be replaced with any valid string to send data on specialized paths. The value of the property can be unset.","ref":"astarte_interfaces.html#io-edgehog-devicemanager-forwardersessionstate-v0-1"},{"type":"extras","title":"Astarte Interfaces - io.edgehog.devicemanager.Geolocation v0.1","doc":"Generic Geolocation sampled data. Geolocation allows geolocation sensors to stream location data, such as GPS data. Values availability depends on what sensors are present on devices and what measurement systems are in use. The id represents a unique identifier for an individual sensor. About This interface is of type datastream and is owned by the device , meaning that it is the device which initiates the data flow. Thanks to this type of interface, the device can send a mutable, ordered stream of data, with no concept of persistent state or synchronization. Data gets sent with an object aggregation. Astarte expects the owner to send all of the interface's mappings at the same time, packed in a single message. Mappings The interface has the following mappings: /%{id}/latitude with double type. Sampled latitude value. /%{id}/longitude with double type. Sampled longitude value. /%{id}/altitude with double type. Sampled altitude value. /%{id}/accuracy with double type. Sampled accuracy of the latitude and longitude properties. /%{id}/altitudeAccuracy with double type. Sampled accuracy of the altitude property. /%{id}/heading with double type. Sampled value representing the direction towards which the device is facing. /%{id}/speed with double type. Sampled value representing the velocity of the device. /%{id}/latitude Sampled latitude value. This endpoint accepts values of type double : a double-precision floating-point number as specified by binary64, by the IEEE 754 standard. The endpoint is parametric and id can be replaced with any valid string to send data on specialized paths. The endpoint has a specific configuration for how data is stored, transferred and indexed. Astarte expects a valid timestamp to be attached each time data is produced. Data is considered delivered when the transport successfully sends the data regardless of the outcome. Data is discarded if the transport is temporarily uncapable of delivering it. Delivered data is kept for 5184000 seconds before it is erased from the database. /%{id}/longitude Sampled longitude value. This endpoint accepts values of type double : a double-precision floating-point number as specified by binary64, by the IEEE 754 standard. The endpoint is parametric and id can be replaced with any valid string to send data on specialized paths. The endpoint has a specific configuration for how data is stored, transferred and indexed. Astarte expects a valid timestamp to be attached each time data is produced. Data is considered delivered when the transport successfully sends the data regardless of the outcome. Data is discarded if the transport is temporarily uncapable of delivering it. Delivered data is kept for 5184000 seconds before it is erased from the database. /%{id}/altitude Sampled altitude value. This endpoint accepts values of type double : a double-precision floating-point number as specified by binary64, by the IEEE 754 standard. The endpoint is parametric and id can be replaced with any valid string to send data on specialized paths. The endpoint has a specific configuration for how data is stored, transferred and indexed. Astarte expects a valid timestamp to be attached each time data is produced. Data is considered delivered when the transport successfully sends the data regardless of the outcome. Data is discarded if the transport is temporarily uncapable of delivering it. Delivered data is kept for 5184000 seconds before it is erased from the database. /%{id}/accuracy Sampled accuracy of the latitude and longitude properties. This endpoint accepts values of type double : a double-precision floating-point number as specified by binary64, by the IEEE 754 standard. The endpoint is parametric and id can be replaced with any valid string to send data on specialized paths. The endpoint has a specific configuration for how data is stored, transferred and indexed. Astarte expects a valid timestamp to be attached each time data is produced. Data is considered delivered when the transport successfully sends the data regardless of the outcome. Data is discarded if the transport is temporarily uncapable of delivering it. Delivered data is kept for 5184000 seconds before it is erased from the database. /%{id}/altitudeAccuracy Sampled accuracy of the altitude property. This endpoint accepts values of type double : a double-precision floating-point number as specified by binary64, by the IEEE 754 standard. The endpoint is parametric and id can be replaced with any valid string to send data on specialized paths. The endpoint has a specific configuration for how data is stored, transferred and indexed. Astarte expects a valid timestamp to be attached each time data is produced. Data is considered delivered when the transport successfully sends the data regardless of the outcome. Data is discarded if the transport is temporarily uncapable of delivering it. Delivered data is kept for 5184000 seconds before it is erased from the database. /%{id}/heading Sampled value representing the direction towards which the device is facing. This endpoint accepts values of type double : a double-precision floating-point number as specified by binary64, by the IEEE 754 standard. The endpoint is parametric and id can be replaced with any valid string to send data on specialized paths. The endpoint has a specific configuration for how data is stored, transferred and indexed. Astarte expects a valid timestamp to be attached each time data is produced. Data is considered delivered when the transport successfully sends the data regardless of the outcome. Data is discarded if the transport is temporarily uncapable of delivering it. Delivered data is kept for 5184000 seconds before it is erased from the database. /%{id}/speed Sampled value representing the velocity of the device. This endpoint accepts values of type double : a double-precision floating-point number as specified by binary64, by the IEEE 754 standard. The endpoint is parametric and id can be replaced with any valid string to send data on specialized paths. The endpoint has a specific configuration for how data is stored, transferred and indexed. Astarte expects a valid timestamp to be attached each time data is produced. Data is considered delivered when the transport successfully sends the data regardless of the outcome. Data is discarded if the transport is temporarily uncapable of delivering it. Delivered data is kept for 5184000 seconds before it is erased from the database.","ref":"astarte_interfaces.html#io-edgehog-devicemanager-geolocation-v0-1"},{"type":"extras","title":"Astarte Interfaces - io.edgehog.devicemanager.HardwareInfo v0.1","doc":"General hardware capabilities About This interface is of type properties and is owned by the device , meaning that it is the device which initiates the data flow. Thanks to this type of interface, the device can set a persistent, stateful, synchronized state with no concept of history or timestamping. Mappings The interface has the following mappings: /cpu/architecture with string type. CPU Architecture /cpu/model with string type. CPU Model Code /cpu/modelName with string type. CPU Model Display Name /cpu/vendor with string type. CPU Vendor /mem/totalBytes with longinteger type. Total RAM quantity (Bytes) /cpu/architecture CPU Architecture This endpoint accepts values of type string : an UTF-8 string, at most 65536 bytes long. The value of the property cannot be unset. /cpu/model CPU Model Code This endpoint accepts values of type string : an UTF-8 string, at most 65536 bytes long. The value of the property cannot be unset. /cpu/modelName CPU Model Display Name This endpoint accepts values of type string : an UTF-8 string, at most 65536 bytes long. The value of the property cannot be unset. /cpu/vendor CPU Vendor This endpoint accepts values of type string : an UTF-8 string, at most 65536 bytes long. The value of the property cannot be unset. /mem/totalBytes Total RAM quantity (Bytes) This endpoint accepts values of type longinteger : a signed 64 bit integer (please note that longinteger is represented as a string by default in JSON-based APIs.). The value of the property cannot be unset.","ref":"astarte_interfaces.html#io-edgehog-devicemanager-hardwareinfo-v0-1"},{"type":"extras","title":"Astarte Interfaces - io.edgehog.devicemanager.LedBehavior v0.1","doc":"About This interface is of type datastream and is owned by the server , meaning that it is the server which initiates the data flow. Thanks to this type of interface, the server can send a mutable, ordered stream of data, with no concept of persistent state or synchronization. Data gets sent with an individual aggregation. Each mapping is treated as an independent value and is managed individually. Mappings The interface has the following mappings: /%{led_id}/behavior with string type. Enum describing the behavior of the given led. Possible values: [Blink60Seconds | DoubleBlink60Seconds | SlowBlink60Seconds] /%{led_id}/behavior Enum describing the behavior of the given led. Possible values: [Blink60Seconds | DoubleBlink60Seconds | SlowBlink60Seconds] Blink60Seconds: Blinking DoubleBlink60Seconds: Double blinking SlowBlink60Seconds: Slow blinking This endpoint accepts values of type string : an UTF-8 string, at most 65536 bytes long. The endpoint is parametric and led_id can be replaced with any valid string to send data on specialized paths. The endpoint has a specific configuration for how data is stored, transferred and indexed. Data is considered delivered when it has been received exactly once by the recipient. Data is discarded if the transport is temporarily uncapable of delivering it. Delivered data is kept for 5184000 seconds before it is erased from the database.","ref":"astarte_interfaces.html#io-edgehog-devicemanager-ledbehavior-v0-1"},{"type":"extras","title":"Astarte Interfaces - io.edgehog.devicemanager.NetworkInterfaceProperties v0.1","doc":"About This interface is of type properties and is owned by the device , meaning that it is the device which initiates the data flow. Thanks to this type of interface, the device can set a persistent, stateful, synchronized state with no concept of history or timestamping. Mappings The interface has the following mappings: /%{iface_name}/macAddress with string type. Normalized physical address. Example value is &quot;00:aa:bb:cc:dd:ee&quot; (always lower case) /%{iface_name}/technologyType with string type. Connection technology. Possible values: [Ethernet, Bluetooth, Cellular, WiFi] /%{iface_name}/macAddress Normalized physical address. Example value is &quot;00:aa:bb:cc:dd:ee&quot; (always lower case) This endpoint accepts values of type string : an UTF-8 string, at most 65536 bytes long. The endpoint is parametric and iface_name can be replaced with any valid string to send data on specialized paths. The value of the property can be unset. /%{iface_name}/technologyType Connection technology. Possible values: [Ethernet, Bluetooth, Cellular, WiFi] This endpoint accepts values of type string : an UTF-8 string, at most 65536 bytes long. The endpoint is parametric and iface_name can be replaced with any valid string to send data on specialized paths. The value of the property can be unset.","ref":"astarte_interfaces.html#io-edgehog-devicemanager-networkinterfaceproperties-v0-1"},{"type":"extras","title":"Astarte Interfaces - io.edgehog.devicemanager.OSInfo v0.1","doc":"About This interface is of type properties and is owned by the device , meaning that it is the device which initiates the data flow. Thanks to this type of interface, the device can set a persistent, stateful, synchronized state with no concept of history or timestamping. Mappings The interface has the following mappings: /osName with string type. Name of the Operating System /osVersion with string type. Version of the Operating System /osName Name of the Operating System This endpoint accepts values of type string : an UTF-8 string, at most 65536 bytes long. The value of the property cannot be unset. /osVersion Version of the Operating System This endpoint accepts values of type string : an UTF-8 string, at most 65536 bytes long. The value of the property cannot be unset.","ref":"astarte_interfaces.html#io-edgehog-devicemanager-osinfo-v0-1"},{"type":"extras","title":"Astarte Interfaces - io.edgehog.devicemanager.OTAEvent v0.1","doc":"OTA Events sampled data. Allows to stream OTA Events data, including OTA Update status, its progress, code and internal message. About This interface is of type datastream and is owned by the device , meaning that it is the device which initiates the data flow. Thanks to this type of interface, the device can send a mutable, ordered stream of data, with no concept of persistent state or synchronization. Data gets sent with an object aggregation. Astarte expects the owner to send all of the interface's mappings at the same time, packed in a single message. Mappings The interface has the following mappings: /event/requestUUID with string type. OTA Request identifier. /event/status with string type. OTA Update status. /event/statusProgress with integer type. Current OTA Update status progress percentage [0%-100%]. /event/statusCode with string type. Status code expands OTA Update status with additional information. /event/message with string type. Contains internal message for status code or empty string otherwise. /event/requestUUID OTA Request identifier. This endpoint accepts values of type string : an UTF-8 string, at most 65536 bytes long. The endpoint has a specific configuration for how data is stored, transferred and indexed. Astarte expects a valid timestamp to be attached each time data is produced. Data is considered delivered when it has been received exactly once by the recipient. Data is discarded if the transport is temporarily uncapable of delivering it. Delivered data is kept for 31556952 seconds before it is erased from the database. /event/status OTA Update status. Value is one of the following strings: Acknowledged : the device received an OTA Request. Downloading : an update is in the process of downloading. Deploying : an update is in the process of deploying. Deployed : an update deployed on the device. Rebooting : the device is in the process of rebooting. Success : an update succeeded. This is a final status of OTA Update. Error : an error happened during the update. Also this status can be used to notify about handled errors. Failure : an update failed. This is a final status of OTA Update. This endpoint accepts values of type string : an UTF-8 string, at most 65536 bytes long. The endpoint has a specific configuration for how data is stored, transferred and indexed. Astarte expects a valid timestamp to be attached each time data is produced. Data is considered delivered when it has been received exactly once by the recipient. Data is discarded if the transport is temporarily uncapable of delivering it. Delivered data is kept for 31556952 seconds before it is erased from the database. /event/statusProgress Current OTA Update status progress percentage [0%-100%]. Every OTA Update status has own progress that starts from 0 and ends at 100, for example (pairs of &quot;status, progress&quot; ): &quot;Downloading, 0&quot; , &quot;Downloading, 50&quot; , &quot;Downloading, 100&quot; , &quot;Deploying, 10&quot; , etc. This endpoint accepts values of type integer : a signed 32 bit integer. The endpoint has a specific configuration for how data is stored, transferred and indexed. Astarte expects a valid timestamp to be attached each time data is produced. Data is considered delivered when it has been received exactly once by the recipient. Data is discarded if the transport is temporarily uncapable of delivering it. Delivered data is kept for 31556952 seconds before it is erased from the database. /event/statusCode Status code expands OTA Update status with additional information. Some common status codes are: InvalidRequest : an update request contains incorrect data. UpdateAlreadyInProgress : another update is currently in progress. NetworkError : a network error happened during the update. IOError : a filesystem error happened during the update. InternalError : an internal error happened during the update. InvalidBaseImage : an update failed to apply due to an invalid base image. SystemRollback : a system rollback has occurred. Canceled : an update was canceled. This endpoint accepts values of type string : an UTF-8 string, at most 65536 bytes long. The endpoint has a specific configuration for how data is stored, transferred and indexed. Astarte expects a valid timestamp to be attached each time data is produced. Data is considered delivered when it has been received exactly once by the recipient. Data is discarded if the transport is temporarily uncapable of delivering it. Delivered data is kept for 31556952 seconds before it is erased from the database. /event/message Contains internal message for status code or empty string otherwise. This endpoint accepts values of type string : an UTF-8 string, at most 65536 bytes long. The endpoint has a specific configuration for how data is stored, transferred and indexed. Astarte expects a valid timestamp to be attached each time data is produced. Data is considered delivered when it has been received exactly once by the recipient. Data is discarded if the transport is temporarily uncapable of delivering it. Delivered data is kept for 31556952 seconds before it is erased from the database.","ref":"astarte_interfaces.html#io-edgehog-devicemanager-otaevent-v0-1"},{"type":"extras","title":"Astarte Interfaces - io.edgehog.devicemanager.OTARequest v1.0","doc":"About This interface is of type datastream and is owned by the server , meaning that it is the server which initiates the data flow. Thanks to this type of interface, the server can send a mutable, ordered stream of data, with no concept of persistent state or synchronization. Data gets sent with an object aggregation. Astarte expects the owner to send all of the interface's mappings at the same time, packed in a single message. Mappings The interface has the following mappings: /request/operation with string type. OTA Request operation /request/url with string type. File URL /request/uuid with string type. Request identifier /request/operation OTA Request operation Value is one of the following strings: Update : push an OTA update operation. Cancel : cancel an OTA update if it can still be cancelled. This endpoint accepts values of type string : an UTF-8 string, at most 65536 bytes long. The endpoint has a specific configuration for how data is stored, transferred and indexed. Data is considered delivered when the transport successfully sends the data regardless of the outcome. Data is discarded if the transport is temporarily uncapable of delivering it. Delivered data is kept for 31556952 seconds before it is erased from the database. /request/url File URL If the operation is Update, this will contain the URL that can be used to download the Update. If the operation is Cancel, this will be an empty string. Note that the URL will be valid only until the OTA update is active (i.e. it didn't reach a Failure or Success state), after that it's possible that the URL can become invalid. This endpoint accepts values of type string : an UTF-8 string, at most 65536 bytes long. The endpoint has a specific configuration for how data is stored, transferred and indexed. Data is considered delivered when the transport successfully sends the data regardless of the outcome. Data is discarded if the transport is temporarily uncapable of delivering it. Delivered data is kept for 31556952 seconds before it is erased from the database. /request/uuid Request identifier A UUID that uniquely identifies the OTA request. It must be stored when receiving an Update operation so that it can be matched against in case a Cancel operation is received. This endpoint accepts values of type string : an UTF-8 string, at most 65536 bytes long. The endpoint has a specific configuration for how data is stored, transferred and indexed. Data is considered delivered when the transport successfully sends the data regardless of the outcome. Data is discarded if the transport is temporarily uncapable of delivering it. Delivered data is kept for 31556952 seconds before it is erased from the database.","ref":"astarte_interfaces.html#io-edgehog-devicemanager-otarequest-v1-0"},{"type":"extras","title":"Astarte Interfaces - io.edgehog.devicemanager.RuntimeInfo v0.1","doc":"About This interface is of type properties and is owned by the device , meaning that it is the device which initiates the data flow. Thanks to this type of interface, the device can set a persistent, stateful, synchronized state with no concept of history or timestamping. Mappings The interface has the following mappings: /name with string type. Name of the Edgehog runtime. Example value: edgehog-esp32-device /url with string type. URL that uniquely identifies the Edgehog Edgehog runtime implementation. Example value: https://github.com/edgehog-device-manager/edgehog-esp32-device . /version with string type. Version of the Edgehog runtime. Example value: 0.5 /environment with string type. Environment of the Edgehog runtime. Example value: esp-idf VERSION , Rust 1.58 or Java 8 /name Name of the Edgehog runtime. Example value: edgehog-esp32-device This endpoint accepts values of type string : an UTF-8 string, at most 65536 bytes long. The value of the property cannot be unset. /url URL that uniquely identifies the Edgehog Edgehog runtime implementation. Example value: https://github.com/edgehog-device-manager/edgehog-esp32-device . This endpoint accepts values of type string : an UTF-8 string, at most 65536 bytes long. The value of the property cannot be unset. /version Version of the Edgehog runtime. Example value: 0.5 This endpoint accepts values of type string : an UTF-8 string, at most 65536 bytes long. The value of the property cannot be unset. /environment Environment of the Edgehog runtime. Example value: esp-idf VERSION , Rust 1.58 or Java 8 This endpoint accepts values of type string : an UTF-8 string, at most 65536 bytes long. The value of the property cannot be unset.","ref":"astarte_interfaces.html#io-edgehog-devicemanager-runtimeinfo-v0-1"},{"type":"extras","title":"Astarte Interfaces - io.edgehog.devicemanager.StorageUsage v0.1","doc":"About This interface is of type datastream and is owned by the device , meaning that it is the device which initiates the data flow. Thanks to this type of interface, the device can send a mutable, ordered stream of data, with no concept of persistent state or synchronization. Data gets sent with an object aggregation. Astarte expects the owner to send all of the interface's mappings at the same time, packed in a single message. Mappings The interface has the following mappings: /%{label}/totalBytes with longinteger type. Total storage size in bytes /%{label}/freeBytes with longinteger type. Available storage bytes /%{label}/totalBytes Total storage size in bytes This endpoint accepts values of type longinteger : a signed 64 bit integer (please note that longinteger is represented as a string by default in JSON-based APIs.). The endpoint is parametric and label can be replaced with any valid string to send data on specialized paths. The endpoint has a specific configuration for how data is stored, transferred and indexed. Astarte expects a valid timestamp to be attached each time data is produced. Data is considered delivered when the transport successfully sends the data regardless of the outcome. Data is discarded if the transport is temporarily uncapable of delivering it. Delivered data is kept for 5184000 seconds before it is erased from the database. /%{label}/freeBytes Available storage bytes This endpoint accepts values of type longinteger : a signed 64 bit integer (please note that longinteger is represented as a string by default in JSON-based APIs.). The endpoint is parametric and label can be replaced with any valid string to send data on specialized paths. The endpoint has a specific configuration for how data is stored, transferred and indexed. Astarte expects a valid timestamp to be attached each time data is produced. Data is considered delivered when the transport successfully sends the data regardless of the outcome. Data is discarded if the transport is temporarily uncapable of delivering it. Delivered data is kept for 5184000 seconds before it is erased from the database.","ref":"astarte_interfaces.html#io-edgehog-devicemanager-storageusage-v0-1"},{"type":"extras","title":"Astarte Interfaces - io.edgehog.devicemanager.SystemInfo v0.1","doc":"Information about the system About This interface is of type properties and is owned by the device , meaning that it is the device which initiates the data flow. Thanks to this type of interface, the device can set a persistent, stateful, synchronized state with no concept of history or timestamping. Mappings The interface has the following mappings: /serialNumber with string type. The serial number of the system /partNumber with string type. The part number of the system /serialNumber The serial number of the system This endpoint accepts values of type string : an UTF-8 string, at most 65536 bytes long. The value of the property cannot be unset. /partNumber The part number of the system This endpoint accepts values of type string : an UTF-8 string, at most 65536 bytes long. The value of the property cannot be unset.","ref":"astarte_interfaces.html#io-edgehog-devicemanager-systeminfo-v0-1"},{"type":"extras","title":"Astarte Interfaces - io.edgehog.devicemanager.SystemStatus v0.1","doc":"About This interface is of type datastream and is owned by the device , meaning that it is the device which initiates the data flow. Thanks to this type of interface, the device can send a mutable, ordered stream of data, with no concept of persistent state or synchronization. Data gets sent with an object aggregation. Astarte expects the owner to send all of the interface's mappings at the same time, packed in a single message. Mappings The interface has the following mappings: /systemStatus/availMemoryBytes with longinteger type. Available memory (Bytes) /systemStatus/bootId with string type. UUID representing the Boot Id /systemStatus/taskCount with integer type. Number of running tasks or processes /systemStatus/uptimeMillis with longinteger type. Get time in milliseconds since boot /systemStatus/availMemoryBytes Available memory (Bytes) This endpoint accepts values of type longinteger : a signed 64 bit integer (please note that longinteger is represented as a string by default in JSON-based APIs.). The endpoint has a specific configuration for how data is stored, transferred and indexed. Astarte expects a valid timestamp to be attached each time data is produced. Data is considered delivered when the transport successfully sends the data regardless of the outcome. Data is discarded if the transport is temporarily uncapable of delivering it. Delivered data is kept for 5184000 seconds before it is erased from the database. /systemStatus/bootId UUID representing the Boot Id This endpoint accepts values of type string : an UTF-8 string, at most 65536 bytes long. The endpoint has a specific configuration for how data is stored, transferred and indexed. Astarte expects a valid timestamp to be attached each time data is produced. Data is considered delivered when the transport successfully sends the data regardless of the outcome. Data is discarded if the transport is temporarily uncapable of delivering it. Delivered data is kept for 5184000 seconds before it is erased from the database. /systemStatus/taskCount Number of running tasks or processes This endpoint accepts values of type integer : a signed 32 bit integer. The endpoint has a specific configuration for how data is stored, transferred and indexed. Astarte expects a valid timestamp to be attached each time data is produced. Data is considered delivered when the transport successfully sends the data regardless of the outcome. Data is discarded if the transport is temporarily uncapable of delivering it. Delivered data is kept for 5184000 seconds before it is erased from the database. /systemStatus/uptimeMillis Get time in milliseconds since boot This endpoint accepts values of type longinteger : a signed 64 bit integer (please note that longinteger is represented as a string by default in JSON-based APIs.). The endpoint has a specific configuration for how data is stored, transferred and indexed. Astarte expects a valid timestamp to be attached each time data is produced. Data is considered delivered when the transport successfully sends the data regardless of the outcome. Data is discarded if the transport is temporarily uncapable of delivering it. Delivered data is kept for 5184000 seconds before it is erased from the database.","ref":"astarte_interfaces.html#io-edgehog-devicemanager-systemstatus-v0-1"},{"type":"extras","title":"Astarte Interfaces - io.edgehog.devicemanager.WiFiScanResults v0.2","doc":"About This interface is of type datastream and is owned by the device , meaning that it is the device which initiates the data flow. Thanks to this type of interface, the device can send a mutable, ordered stream of data, with no concept of persistent state or synchronization. Data gets sent with an object aggregation. Astarte expects the owner to send all of the interface's mappings at the same time, packed in a single message. Mappings The interface has the following mappings: /ap/channel with integer type. The channel over which the client is communicating with the access point. /ap/connected with boolean type. Identifies if the device is connected to this Access Point /ap/essid with string type. Extended Service Set Identification of the current AP, empty string if the AP is hidden. /ap/macAddress with string type. Lower case mac address string formatted like de:ad:be:ff:11:22 . /ap/rssi with integer type. The current signal strength measured in dBm. /ap/channel The channel over which the client is communicating with the access point. The channel represents one of the ranges into which the reference frequency is divided and it's identified by an integer number in the range 1 - 165, depending on the frequency itself and the region. This endpoint accepts values of type integer : a signed 32 bit integer. The endpoint has a specific configuration for how data is stored, transferred and indexed. Astarte expects a valid timestamp to be attached each time data is produced. Data is considered delivered when the transport successfully sends the data regardless of the outcome. Data is discarded if the transport is temporarily uncapable of delivering it. Delivered data is kept for 5184000 seconds before it is erased from the database. /ap/connected Identifies if the device is connected to this Access Point This endpoint accepts values of type boolean : either true or false, adhering to JSON boolean type. The endpoint has a specific configuration for how data is stored, transferred and indexed. Astarte expects a valid timestamp to be attached each time data is produced. Data is considered delivered when the transport successfully sends the data regardless of the outcome. Data is discarded if the transport is temporarily uncapable of delivering it. Delivered data is kept for 5184000 seconds before it is erased from the database. /ap/essid Extended Service Set Identification of the current AP, empty string if the AP is hidden. This endpoint accepts values of type string : an UTF-8 string, at most 65536 bytes long. The endpoint has a specific configuration for how data is stored, transferred and indexed. Astarte expects a valid timestamp to be attached each time data is produced. Data is considered delivered when the transport successfully sends the data regardless of the outcome. Data is discarded if the transport is temporarily uncapable of delivering it. Delivered data is kept for 5184000 seconds before it is erased from the database. /ap/macAddress Lower case mac address string formatted like de:ad:be:ff:11:22 . This endpoint accepts values of type string : an UTF-8 string, at most 65536 bytes long. The endpoint has a specific configuration for how data is stored, transferred and indexed. Astarte expects a valid timestamp to be attached each time data is produced. Data is considered delivered when the transport successfully sends the data regardless of the outcome. Data is discarded if the transport is temporarily uncapable of delivering it. Delivered data is kept for 5184000 seconds before it is erased from the database. /ap/rssi The current signal strength measured in dBm. This endpoint accepts values of type integer : a signed 32 bit integer. The endpoint has a specific configuration for how data is stored, transferred and indexed. Astarte expects a valid timestamp to be attached each time data is produced. Data is considered delivered when the transport successfully sends the data regardless of the outcome. Data is discarded if the transport is temporarily uncapable of delivering it. Delivered data is kept for 5184000 seconds before it is erased from the database.","ref":"astarte_interfaces.html#io-edgehog-devicemanager-wifiscanresults-v0-2"},{"type":"extras","title":"Astarte Interfaces - io.edgehog.devicemanager.config.Telemetry v0.1","doc":"About This interface is of type properties and is owned by the server , meaning that it is the server which initiates the data flow. Thanks to this type of interface, the server can set a persistent, stateful, synchronized state with no concept of history or timestamping. Mappings The interface has the following mappings: /request/%{interface_name}/enable with boolean type. Enable/Disable telemetry update. Unset returns to the previous state configured in the device. /request/%{interface_name}/periodSeconds with longinteger type. Set interval of period seconds between the end of the previous update and the start of the next one. Unset returns to the previous state configured in the device. /request/%{interface_name}/enable Enable/Disable telemetry update. Unset returns to the previous state configured in the device. This endpoint accepts values of type boolean : either true or false, adhering to JSON boolean type. The endpoint is parametric and interface_name can be replaced with any valid string to send data on specialized paths. The value of the property can be unset. /request/%{interface_name}/periodSeconds Set interval of period seconds between the end of the previous update and the start of the next one. Unset returns to the previous state configured in the device. This endpoint accepts values of type longinteger : a signed 64 bit integer (please note that longinteger is represented as a string by default in JSON-based APIs.). The endpoint is parametric and interface_name can be replaced with any valid string to send data on specialized paths. The value of the property can be unset.","ref":"astarte_interfaces.html#io-edgehog-devicemanager-config-telemetry-v0-1"}]